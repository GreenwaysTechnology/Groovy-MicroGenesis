Lab Setup:
.........

1.JDK 1.8
2.JAVA_HOME -  jdk/
3.Groovysdk
4.IDE 
   IntelliJ IDEA
   Groovy console.
//////////////////////////////////////////////////////////////////////////////////////////////

What is Groovy? Groovy Programming language?

 Groovy is programming language for jvm.


JVM -Java Virtual Machine - To run java applications

JVM helps to build platform indepdendent applications.

java application can be written using programming language called "Java programming language"

Java pl
 -It is high level pl
 -Object oriented Programming.

Java applications:

Editions:

-JAVA SE - Standard Edition - Core java
-JAVA EE - Enterprise edition - Server apps - web apps,Web services,databases,distributed...
-JAVA ME - Micro Edition - Mobil,card,device apps.

Java Technology created by SUN microsystem at 1989,later acquired by Oracle.
//////////////////////////////////////////////////////////////////////////////////////////

Standards organization:

C was standarized by ANSI
javascript ECMA
SQL ANSI.
.....

JAVA who is standarizing?

JCP - Java Community Process
JSR 

Core spec:
1.jvm spec

2.jse spec

3.jee spec
   servlet spec
   webservice spec

JSR-223 Spec published on may 2003 June.
JSR 223: Scripting for the JavaTM Platform

JSR-223 Objective:

Before that,
only one lanugage was there for jvm- java pl.
we can write , compile,run java programs on jvm

Groovy was the first  Scripting language for jvm ,which was created based JSR-223 Spec.
///////////////////////////////////////////////////////////////////////////////////////////

Groovy is dialect of java which is running on JVM.


                                     JAVA code  - Hello.java
					 | 
                                      java compiler-javac -Hello.class (byte code)
                                          |
                                      java Hello - Run time
					|
				    Java Runtime Env -JVM



VM Poly glot.
       
                JPL  Groovy   Kotlin   JRuby Scala 
		----------------------------------
				|
			     .class
				|
			       JVM
//////////////////////////////////////////////////////////////////////////////////////////////

Groovy is programming language inspired from java,Ruby,Javascript,Perl, Smalltalk, Objective-C


Groovy is
  -object oriented
  -functional style
  -dynamic typed
  -static typed 
  -delcarative
  -dsl
Programming language.

OO talks about How to decompose Realtime problems thinking interms objects.

...............................................................
Object oriented Concepts:
1.Abstraction
2.Encapsulation
3.Modularity
4.Hierachy
5.Typing
6.Persistency
7.Concurrency
...............................................................
functional Programming:
......................

Functional is one of the programming paradigm, which is very oldest among all Programming styles.

Groovy was the first programming language introduced funcitonal programming principles on java.

//////////////////////////////////////////////////////////////////////////////////////////

Type System in java:
....................

Java is static typed/strongly typed programming language.
   : The compiler vertifies the type of variable to test whether is comptable or not
if not compiler will throw error.

int a=10;

int is type
a is variable
10 is value

during compile time, the compiler tests whether a has proper type

int a=true;

a cant hold true, because it is boolean, the compiler verfies the type of a .

Dynamic typing:

 the compiler wont verify the type of a variable during compiletime.

Dynamic typed/weak typed programming language.

                             "Groovy can support both"
/////////////////////////////////////////////////////////////////////////////////////////////

Programming styles:
...................

1.Imperative

class Calc{
   int add(int a, int b){
      return a + b;
   }
}
Calc c=new Calc();
c.add(10,10) - 20

2.Delcarative

<h1>Hello</h1>
add 10 10 - 20

->More readable,Simple to use.

Can i write program without proper programming experience?
Yes

follow declarative programming : 

 Any one can write code.

eg:
 -Dev ops
 -scripts written using xml,json,yaml,

Programming languages:

1.GPL - General Purpose Programming language :Imperative

  The language is designed not specific to particular domain
C,C++,Java,Java Script.

2.DSL -  Domain Specific programming language.
 The language is designed for specific use case or domain.
HTML,PHP....


DLS means sepcific,declarative,easy to understand, any body can code.

                 "DSL:readable business rules in your applications"

"Groovy can help to build reusable Dsl".


DSL code:
 move left,move right, 
 take 1 cup of milk add 2 gm sugar
 shutdown machine-1 at 1 pm every day and restart after 2pm 

Machine Health Checkup:
1.find Machine at all locations
2.filter machines which are unhealthy
3.prepare report in pdf mail to healthCheckMaster@tcs.com
4.do this every day at 1pm

Groovy dsls are easy to understand by stack holders,tools users,end users,dev ops enginers.
............................................................................................

Core Features of Groovy Lanaguage:

1.Closures
2.builders
3.runtime & compile-time meta-programming
4.functional programming
5.type inference and static compilation
6.Integration with existing java stack.

//////////////////////////////////////////////////////////////////////////////////////////

Groovy Eco System:
.................
Groovy is core programming language only.

Web:
  Dynamic Web Apps | RestFull Web Services
1.Grails 
  Framework written using groovy.

Build System:
  1.ANT
  2.Maven
  3.Gradle
  4.Grape

2.Gradle
   Build system for java written in groovy

Testing Framework:
 Junit
3.Spock:
  Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification language.

Package Managers:

NPM - javascript
Nuget -MS .NET

4.SDKMAN!  -Groovy

5.Microservices:
 Spring with Groovy
 Micronaut  -Groovy

SOAP UI - SCRIPTS Written in groovy.
////////////////////////////////////////////////////////////////////////////////////////////

Groovy : Setup:

Groovy can be installed in many ways
...................................
1. Download a source or binary distribution.

2.Use a package manager-sdkMan or bundle for your operating system.

3.Grab the latest plugin for your IDE and follow the installation instructions.

4.Find the latest source code in the Git repo (or the GitHub mirror).

5.If you're using Docker, Groovy is available on Docker Hub.
////////////////////////////////////////////////////////////////////////////////////////////

JDK 1.8.X

Set path in env 

JAVA_HOME
  C:\Program Files\Java\jdk1.8.0_161
PATH
 C:\softwares\apache-groovy-sdk-3.0.7\groovy-3.0.7\bin


Tools provided by groovy:

1.compiler 
  groovyc
 compile groovy into .class.
2.groovy
   To run groovy code. here we dont need to compile.
  java Main  groovy Main
3.groovy console
   -Built in ide to write groovy code
4.REPL  - Read Evaulate Print Loop : Interactive cmd line tool.-groovysh : groovy shell - Wrapper to low level services.


Groovy programs are saved with "filename.groovy"

////////////////////////////////////////////////////////////////////////////////////////////

Program types:

1.Script Program
2.Class based Program

Compile And Exection Model:
groovyc  FileName.groovy ----FileName.class--load on jvm
//////////////////////////////////////////////////////////////////////////////////////////////

Lets Coding:

1.simple coding using groovy console.

2.Using idea editor

3.vs code editor.


java code

package com.mycom;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }

}
///////////////////////////////////////////////////////////////////////////////////////////

C:\session\MicroGenesis\groovy-level-1> 

helloworld.groovy
println "Hello Groovy World"

C:\session\MicroGenesis\groovy-level-1> groovy helloworld.groovy
Hai Groovy!!!



The above code

- dont have its own class like java
- dont have main method like java
- dont have semicollons like java

Since groovy is code but how it is running?

Groovy adds automatically the below code.


What is happening after compilation?

HelloWorld.groovy

println "hello";

After compilation Groovy compiler writes a code like below

import org.codehaus.groovy.runtime.InvokerHelper;

class HelloWorld extends Script {    
                 
    def run() {                                 
  	println "hello";               
    }
    static void main(String[] args) {           
        InvokerHelper.runScript(HelloWorld, args)     
    }
}

1.The HelloWorld class extends the groovy.lang.Script class

2.groovy.lang.Script requires a run method returning a value
  the script body goes into the run method

3.the main method is automatically generated
 
4.and delegates the execution of the script on the run   method
/////////////////////////////////////////////////////////////////////////////////////////////

Groovy topics:
.............

Groovy Language:
...............

1.Language Fundamentals
2.Groovy Object orientations
3.Groovy Closures and Functional Programming
4.Groovy Meta Programming
5.Groovy DSL
6.Groovy and Builders
7.Groovy and Collections
8.Groovy and IO
    -File,
    -JSON
    -XML

/////////////////////////////////////////////////////////////////////////////////////////////


1.Language Fundamentals

1.1.Type system
1.2.literals
1.3.variables
1.4.operators
1.5.control structures
1.6.iterators/loops

Types ,literals ,variables:
.............................
Groovy is dynamic , static typed programming lanugage.

variables are other wise called as "identifiers"

syntax:

Strong typing
 
type variable=value

eg;
 int a =10;

There are two types of datatype

1.primitive  -  int,float,char,boolean....
2.complex/userdefined/ data type - Object types - Customer/Employee....
///////////////////////////////////////////////////////////////////////////////////////////

Lab:

strongtype.groovy
//Strong typing
/**
 * Primitive Types in java
 *  -integers
 *      byte
 *        -128 to 127
 *        1 byte
 *      short
 *       -32,768 to 32767
 *       2 bytes
 *      int
 *       -2Powof31 to 2powerof32
 *       4 bytes
 *       long
 *       - -2power63 to 2powerof64
 *       8 bytes
 *
 *  -float
 *     float - 4bytes
 *     double -8bytes
 *  -char
 *    char- 16 bit unicode char
 *  -boolean
 *     boolean
 *     1 bit - 0 / 1
 *
 *  Reference type/Object Types
 *  Employee e = new Employee();
 *  e - reference variable
 *  Employee - type
 *
 *  Strings are reference types
 *
 */
int a = 10;
float f = 10.5;
char c = 'A';
boolean isActive = true;
double d = 10.89;
short s = 400000;
long l = 100000000;
byte b = 900;

//Reference type
String str = "Hello Groovy";

System.out.println(" Integer " + a);
println("Float " + f);
println "Character " + c;
println "Boolean " + isActive;
println "double" + d;
println "Short " + s;
println "Long " + l;
println "byte  " + b;
println "String " + str

//////////////////////////////////////////////////////////////////////////////////////////////

Weak Typing / Dynamic Typing:
............................

The type of variable is not known during compile time.

syntax;

def identifier(variable)=value(literal)

def - keyword

//Dynamic typing

//int x=10;
//x ="hello";
def myvar = 100;
println "MyVar " + myvar;
myvar = "Hello";
println "MyVar " + myvar;
myvar = true;
println "MyVar " + myvar;
myvar = 10.6;
println "MyVar " + myvar;
myvar = 'c';
println "MyVar " + myvar;
////////////////////////////////////////////////////////////////////////////////////////////

How to know the Type of Identifier?
  
def myvar=100;

instanceof operator used to know the type of variable.

instanceof operator works only with reference types

myvar instanceof int -  compile time error

int -primitive -Reference type for Integer

java provides prmitive data eq Object type(Reference types) which are called "Wrapper Classes".
   Every prmitive type eq Reference type is there

 byte   - Byte 
  :The Byte class wraps a value of primitive type byte in an object.
 short  -  Short
 int    - Integer
 long   -Long
 float  -Float
 double -Double 
 boolean -Boolean
 char    - Character 
 NOPrimitive ------String


////////////////////////////////////////////////////////////////////////////////////////////

Code challange:
...............
In java, i want to store the below number, findout right data type.

myvariable =2232333333333333333333333333333333333331212121212092347329473433483473984732948734983473984739473498473289472394238437498479487948749387492479479347943794479;


//Identify the type of variable.
//instance of operator tells that the variable belongs to what type ?
//either byte /short/long/int.
//variableName instanceof Type

def myvar = 1;
println "My var instance of   : " + myvar instanceof Byte;
println "My var instance of   : " + myvar instanceof Short;
println "My var instance of   : " + myvar instanceof Integer;
println "My var instance of   : " + myvar instanceof Long;
println "My var instance of   : " + myvar instanceof Float;
println "My var instance of   : " + myvar instanceof Double;
println "My var instance of   : " + myvar instanceof BigInteger;
println "With out string concation"
println myvar instanceof Integer
println myvar instanceof Short
println myvar instanceof Byte
println myvar instanceof Long

println "initalizing with long numbers"
myvar = 999999999999999;
println myvar instanceof Integer
println myvar instanceof Short
println myvar instanceof Byte
println myvar instanceof Long
println "initalizing with big  numbers"
myvar = 9999999999999999777777777777777777777777777777777777777777777777777777777777777777;
println myvar instanceof Integer
println myvar instanceof Short
println myvar instanceof Byte
println myvar instanceof Long
println myvar instanceof BigInteger
/////////////////////////////////////////////////////////////////////////////////
println "String identification"
myvar = "hello world"
println myvar instanceof String;
println "Character identification"
myvar = 'A';
println myvar instanceof Character;
println myvar instanceof String;
////////////////////////////////////////////////////////////////////////////////////////////
println "Boolean identification"
myvar = true;
println myvar instanceof Boolean;
/////////////////////////////////////////////////////////////////////////////////////////////////
println "Decimal identification"
myvar = 10.89000;
println myvar instanceof Float; //false
println myvar instanceof Double; //false
println myvar instanceof BigDecimal; //true
///////////////////////////////////////////////////////////////////////////////////////////////////

Type conversion:
...............

Java : 

int a = 10;

int - type
a - variable/identifier
10- value/literal

what is type of a?
  int

how do you say type of a?
 based on type only not based on value.

Is there any type for value?

 what is type of 10 - ?

Yes!....

in Integer family : the default type of value is "int"

int a =10;

a's type is int
10's type is also int.

Type conversion :
 Converting from one type to another type.

 int to byte

Types of conversion:

 - Implicit conversion
     conversion is taken automatically.
     byte b =10;  ===byte ==int
    here 10(int) is converted into byte.   
   int b =9000; ==>int === int

 - Explicit conversion
      We need to convert manually.
  While conversion there is possibility of data loss.
   
   Syntax
 
      targettype = (targetype)sourcetype
      byte b = (byte)900;
  
      int a = 10; //10 type is int---size 4 bytes
        byte b = 19; // 19 type is ? - int only  // byte(2) === int(4)
        //byte b1 =9000; // here 9000 cant be stored inside b1 because b1 capacity is lesser than value
        //what if i want to store 9000 inside b1
        //type conversion
        byte b2 = (byte)10000;
        System.out.println(b2);

/////////////////////////////////////////////////////////////////////////////////////////////

Decimal numbers:
................
What is default type of decimals?

float price = 10.5;  // float === double === 4 bytes ===8 bytes- error

what is type of 10.5?
  double.

type conversion for floating points

ways:

1. by adding f suffix
	
        float price = 10.5f;

here 10.5(double) is converted into float.

2.by using () syntax
      float price1 = (float) 10.5;

//////////////////////////////////////////////////////////////////////////////////////////////

Characters:

the value of char type is int

        char c = 'A'; //int
        char c1 = 99; //int
        System.out.println(c1 + " " + c);
        System.out.println((char) c1 + " " + (int) c);

/////////////////////////////////////////////////////////////////////////////////////////

Groovy  Type Conversion:
//////////////////////////
Groovy mostly takes care of type conversion implicitly.

//type conversion
//int is converted to byte.
byte b = 10000;
println b;
byte b1 = (byte) 10000;
println b1;

float f = 10.5;
float f1 = 10.5f;

println f;
println f1;

//////////////////////////////////////////////////////////////////////////////////////////////////

//Dynamic typing and type conversion

def myvar = 100;
println myvar instanceof Integer /// int
//What if i want to convert into Short, i want to represent in side short/long/byte
def myvar2 = 100 as Short;
println myvar2 instanceof Integer /// int
println myvar2 instanceof Short /// int
//////////////////////////////////////////////////////////////////////////////////////////////

Other Type conversion:
......................

1.Boxing
2.Unboxing
 
Boxing and Un boxing : converting primitive to wrapper and wrapper to primitive
 Integer j = 10;
 int y = j * 10;
 System.out.println(y);

//type conversion
//int is converted to byte.
byte b = 10000;
println b;
byte b1 = (byte) 10000;
println b1;

float f = 10.5;
float f1 = 10.5f;

println f;
println f1;

//////////////////////////////////////////////////////////////////////////////////////////////////

//Dynamic typing and type conversion

def myvar = 100;
println myvar instanceof Integer /// int
//What if i want to convert into Short, i want to represent in side short/long/byte
def myvar2 = 100 as Short;
println myvar2 instanceof Integer /// int
println myvar2 instanceof Short /// int
//////////////////////////////////////////////////////////////////////////////////////////////

Integer j = 10;
int y = j * 10;
println y;

def x = 100;
def result = x * 100;
println result;

/////////////////////////////////////////////////////////////////////////////////////////////

Comments;

1.single line comment:

//

2.Muliti line comment
/*

*/

3.Groovydoc comment
 /**
 *
 *
 /

4.Shebang line

#! /user/bin/env/ groovy

  This for running script directly from the commandline in unix operating system.

///////////////////////////////////////////////////////////////////////////////////////////
                            Key words from groovy


NOte: 

 Keywords cant be used as value or variable in groovy.

 eg: 
 as, breakcase,catch,class, instance of,for, goto def, enum do, const,...........
//////////////////////////////////////////////////////////////////////////////////////////////

Coding Best practices for identifier(variable)
...............................................

- starts with letter,
- starts with $
- starts with _
- not with numbers
 
/////////////////////////////////////////////////////////////////////////////////////////////

Difference with Java:
.....................

Groovy makes code as simple as possible.Groovy uses lot of boilerplate code on behalf of us.

Typical java program structure :

package com.mycompany.project.module.submodule;

import java.util.*;
import java.math.BigInteger;


public class MyClass{

 public static void main(String args[]){

 }
 
}

Groovy Program Structure: Script style,Class based


package is optional

most of the import statements are optionals


script code .....
  -variables ... def a=10; double price=1000;

  -function declarations...

class style:

package 

import statments you can have....

class MyClass{
 

}

////////////////////////////////////////////////////////////////////////////////////////////

1.Default imports.

Java :

  java.lang package is default.

package is logical grouping of code(classes and interfaces).
packages are represented physically as collection of folders.

eg:
   package com.mycom

com is folder
mycom is another folder.

Types of packages:

1.in built packages 
   - packages are offered by language itself.
 in built packages starts with java javax

java.lang
java.util
java.math
java.io
java.net
java.sql
.....etc...

javax.servlet

Note: we cant keep any built in packages for our own packages.


2.custom packages
  packages are created by application developers

 com - company
 org -organization

Syntax / Naming standards:

  com.companyname.projectname.module.submodule.

  com.microgenesis.pms;

  com.microgenesis.pms.profile


  com.microgenesis.pms.profile.search

  
3.Third party packages

  packages are distributed by commnity

 com.atlassian.jira.issue.comments
 com.atlassian.jira.api

////////////////////////////////////////////////////////////////////////////////////////////

Grooy has lot of default packages; you dont need to import them.

1.java.io.*;
2.java.lang.*;
3.java.math.BigDecimal
4.java.math.BigInteger
5.java.net.*
6.java.util.*
/////////////////////////////////////////////////////////////////////////////////////////

Groovy language also has its own packages

 Groovy has extend from java, which supports all java packages + who supports extra packages.

groovy.XXX

groovy.lang.*;
groovy.util.*;
////////////////////////////////////////////////////////////////////////////////////////////

; and groovy

In groovy ; optional.


////////////////////////////////*************************///////////////////////////////////

Values In Groovy:
.................

1.Strings && Characters
2.Numbers
3.Booleans
4.Lists
5.Arrays
6.Map
7.Objects
/////////////////////////////////////////////////////////////////////////////////////////////

Strings:
 Text literals are represented in the form of collection of characters called strings.
 Strings are Objects.
 Strings are instance of java.lang.String class as well as groovy.lang.GString
 Characters in groovy is represented in String object.
 Each character is 16-bit unicode character.


String declaration Patterns:
............................

1.single quoted  - ''
2.Double quoted  = "" 
3.Triple  Single Quoted = '''
4.Triple double quoted = """
5.slashy quoted - / /
6.Dollar slashy quoted - $/ /

///////////////////////////////////////////////////////////////////////////////////////////// 

1.single quoted:

def singleStr = 'Hello,SingleQuoted Strings '
println singleStr instanceof java.lang.String;
println singleStr;
/////////////////////////////////////////////////////////////////////////////////////////////

2.Double qutoed

def doubleQuotes = "Hello,Double Quotes"
println doubleQuotes instanceof java.lang.String;
println doubleQuotes;

String Concatnation;
....................
println "............................."
def name = "Subramanian";
def greeting = 'Hello ' + name;
println greeting;
println greeting instanceof java.lang.String;
greeting = "Hello " + name;
println greeting;
println greeting instanceof java.lang.String;

Interpolation:
 -It is replacement of existing string concation
 -way of access variables/expression inside string is so different
 -This feature is not available in java language
 
in order to add interpolation syntax, groovy has added a new class groovy.lang.GString

GString Syntax:

 "${expression}"
 "$expression"
println "..........String Interpoltion : GString..................."

def firstName = "Subramaian";
def newGreeting = "Hello ${firstName}";
println newGreeting;
println newGreeting instanceof java.lang.String
println(newGreeting instanceof groovy.lang.GString)
//simplified version
newGreeting = "Hello $firstName";
println newGreeting;
//numerical expression
def salary =1000;
def noofdays =100;
def totalSalary ="Total Salary is ${salary * noofdays}"
println("$totalSalary")

Note: single quote cant have string interpolation - $
//////////////////////////////////////////////////////////////////////////////////////////////

Mutil Line Strings:
...................

How to write multi line strings in java

    String title = "Micro";
        String doc = "<html>" +
                "<head>" +
                "<title>" + title + "</title>" +
                "<body>" +
                "<h1> Hello</h1>" +
                "</body>" +
                "</body></html>";
        System.out.println(doc);

Groovy Multi line strings:
 -triple quote single quto 

println "..........Multi line : triple single quote..................."

def htmlDoc = ''' 
   <html>
      <title>Micro</title>
      <body>
         <h1> Hello</h1>
      </body>
     </html>
'''
println htmlDoc;

-triple quote double quote : With String interpolation.

println "..........Multi line : triple double quote..................."
def title = 'Micro Technology';
def htmlnewDoc = """
   <html>
      <title>$title</title>
      <body>
         <h1>Hello</h1>
      </body>
     </html>
"""
println htmlnewDoc;
//////////////////////////////////////////////////////////////////////////////////////////////

Escaping Special Characters:
............................

//here i want to print single
def quote = " Hello ! how are you? \\ i am fine what \" about you ";
println quote;
quote = ' Hello ! how are you? \' i am fine what about you';
println quote;

quote = " Hello ! how are you? \t \t i am fine what \n about you";
println quote;

def priceInEuro = "Price in Euro \u20AC";
println priceInEuro

special characters you can escape:
...................................

\b - backspace
\f - formfeed
\t  -tab
\s -single space
\' - single quote within single quoted.
\" - double quote witthin another double quote
\unicode - unicode escape
//////////////////////////////////////////////////////////////////////////////////////////

Slashy String:
..............
 Strings inside slash / strings /

// Slashy Strings

//syntax : 1 simple strings
def myValue = / This is demo slashy /;
println myValue
//syntax : 2 with escaped with back slash
def myquote =/How are you! \i am fine \;/;
println myquote
//syntax 3 : multi line with slashy strings
def doc = / hello
 how are you?
 welcome
 greetings   
/;
println doc;
// syntax 4 : interpolation with slashy strings

def name='Subramanian'
def greeting= / Hello ${name} /;
println greeting

Applications of Slashy;

-Text Processing:
  In any language, text processing can be done using "Regular Expression" : Regex.

String mydata = " hey \; \$ hello 0 1, how are y subramanian , 7m3 ";

i want  to extract nos
i want to extract special characters
i want to only $

Task: write a code-java to extract nos,spicial characters,$

String Processing is most common task in programming.
Unix os introduced text processing methods - Streams

Unix text processing programs - utitility programs- dsl's

grep input | x | y | result -Unix dsl for text processing.

Regular Expression:
  Regular expression is dsl language to process strings / text
  Regular expression works based on symbols called "Patterns"
  Now a days every programming language supports Regular   Expression,language runtime and compiler provides regular   expression support.


Regular expression in java:

java.util.regex;

Regular expression uses symbols
 +
 *
 ~
 {}
 ?

Simple Pattern syntax:
......................

 \d+ -match /find any number in the string - match any number one or more times

Declare pattern in java
  
   String pattern =  "\d+"; -  this is compile time error because, special characters
needed to be escaped.
   
   String pattern ="\\d+" -  now it is vaild , because we have escaped \+ chacter by \

Drawback of this syntax:
  Very complex , when we form complex regular expressions
eg:
 "\\+d\\+d\\*d ^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$


package com.mycom;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PatternMatching {
    public static void main(String[] args) {
        System.out.println("Regular Expression using Java");
        String inputString ="hey  hello 0 1, how subramanian 1 , 7m3";
        // \+d - pattern syntax in regular expression.
        String pattern =  "\\d+";
        System.out.println(pattern);
        //Compile the Pattern
        Pattern compiledPattern = Pattern.compile(pattern);
        Matcher digitMatcher =compiledPattern.matcher(inputString);
        System.out.println("Source String "+ inputString);
        while(digitMatcher.find()) {
            System.out.println(digitMatcher.group());
        }

    }
}

Groovy Simplifies the above pattern matching using "Slashy Strings"
.....................................................................

Version : 1 

Just Replace patterns with slashy strings, continue others with java apis

import java.util.regex.Matcher
import java.util.regex.Pattern

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
//Step 2: declare string inside slashy String
String pattern = /\d+/;
Pattern compiledPattern = Pattern.compile(pattern);
Matcher digitMatcher = compiledPattern.matcher(inputString);
println("Source String " + inputString);
while (digitMatcher.find()) {
    println(digitMatcher.group());
}

Version 2: Replace compile Code:
.................................
-Replace Pattern.compile api with ~/d+/
  => "~" is operator - compile operator,later we will discuss this deeply.

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
Pattern compiledPattern = ~/\d+/;
Matcher digitMatcher = compiledPattern.matcher(inputString);
println("Source String " + inputString);
while (digitMatcher.find()) {
 println(digitMatcher.group());
}

//
Version 3 :  slashy +pattern.compile + pattern.matcher
........................................................
 (inputString =~/\d+/)

 "=~" - Compile + Match operator.

println "Regular Expression-Groovy Implementation"
//Step 1: declare input string
def inputString = "hey  hello 0 1, how subramanian , 7m3";
def compiledPattern = ~/\d+/;
def matcher = (inputString =~ /\d+/)
while (matcher.find()) {
    println(matcher.group());
}

//////////////////////////////////////////////////////////////////////////////////////////

Coding Challange:
.................
Finding all dates in a String and getting
//the date month and year can be as simple as below

[dd-mm-yyy] - output format

def dates = "28-02-1992 a b c  15-06-1982 15-Apr-1982";

Expected output:

28-02-1992, 15-06-1982
/////////////////////////////////////////////////////////////////////////////////////////////
dollar SlashyString:
->Multi line + String interpolation

  $// - multi line without interploation
  $/""" xxx """/ multi line with interploation

println "Dollar Slashy Strings";

def name ="Subramanian"
def dollarSlashy = $/ 
   Hello,$name
   100
   prices
   1
   groovy
   34
/$
println dollarSlashy
def matcher = (dollarSlashy =~ /\d+/)
while (matcher.find()) {
    println(matcher.group());
}
////////////////////////////////////////////////////////////////////////////////////////////

Numbers:

Primitives : 
  byte,short,int,long
  float,double
  boolean
  char
Reference types
  Integer - Wrapper classes
  java.math.BigDecimal , java.math.BigInteger

def a =100;
a instanceof Integer

How groovy identifies Integer
  Integer.MAX_VALUE 

How groovy identifies Long
  Integer.MAX_VALUE + 1 - posstive
  Integer.MAX_VALUE - 1 - negative values

Numbers can be represented 
 -binary
    -prefx 0b

println("Numbers")
println "Binary Numbers"
def a=0b10101111
println a;

 -octaal
     -prefix 0
println "Octal "
def b = 077;
println b;

-hexadecimal
   -prefix  0x

println "Hexa decimals"
def c = 0x77;
println c;


 -decimals

println "Decimal literals"

def d =10;
BigDecimal bd =90.89;
println("$d $bd")

Underscore in literals
......................
  when writing long numbers , its harder to read, in order to group long numbers
 "_" notation is used.

eg: credit card numbers,sss,adharno,bigamount..


println "Under scores"

long creditCardNumber = 1234_5678_9012_3456L;
println creditCardNumber
////////////////////////////////////////////////////////////////////////////////////////////

Number suffixes:

 float f =10.5f

 f / F - float
 d / D - double
 l/L   - long
 G/g   - BigInteger
 G/g    -BigDecimal
 i - Integer

long l = 1233l;
int  j = 89i;

Math Operations: later we will see in operators sections
...............................................................................................
Booleans:

In java booleans are represented by boolean type with value "true/false".

Booleans In java:

        boolean isActive = true;
        boolean isEnabled = false;
        //booleans inside if to check condition whether is true or not
        if (isActive) {
            System.out.println("Active");
        } else {
            System.out.println("InActive");
        }
        if (isEnabled) {
            System.out.println("Enabled");
        } else {
            System.out.println("Disabled");
        }
        //Result of some relational and conditional operators
        int a = 108;
        if (a > 100) {
            System.out.println("A is greater than 100");
        } else {
            System.out.println("A is not greater than 100");
        }

Groovy  and Booleans:
.....................

def start = 0;
//int start =0;
if (start) {
    println("START");
} else {
    println("STOP");
}

def name = "Subramanian";
if (name) {
    println "NAME Found"
} else {
    println "NAME not Found";
}

Groovy truthy and falsy values:
...............................
In Groovy everthing is true execept the below values

falsy values:

1.boolean false
2.0
3."" (Empty string)
4.null 
5.Empty list => []
6.Empty Map  => [:]

/**
 * Booleans in Groovy
 */

def isActive = true;
def isEnabled = false;
boolean status = true;
def a = 10;

if (isActive) {
    println "Active"
} else {
    println "InActive"
}
if (isEnabled) {
    println "Enabled"
} else {
    println "Disabled"
}
if (status) {
    println "Ok"
} else {
    println "NotOk"
}
if (a > 100) {
    println("A is greater than 100");
} else {
    println("A is not greater than 100");
}
/////////////////////////////////////////////////////////////////////////////
def start = 0;
//int start =0;
if (start) {
    println("START");
} else {
    println("STOP");
}

def city = "";
if (city) {
    println "CITY Found"
} else {
    println "CITY not Found";
}
def emp = null;
if (emp) {
    println "EMP Found"
} else {
    println "EMP not Found";
}

def name = "Subramanian";
if (name) {
    println "NAME Found"
} else {
    println "NAME not Found";
}
////////////////////////////////////////////////////////////////////////////////////////////

Collection Values : Data Structure
  List
  Set
  Map

List :
 java.util.List
 
how to declare list?
println "...............List..................."

def list = [1, 2, 3, 45, 66];
println list;
println list instanceof java.util.List
println list instanceof java.util.ArrayList
def names = ["Subramanian", "Geetha", "Ram", "Karthik"];
println names
def something = [1, "hello", 2, true];
println something

//declare linkedList
def nodes = [1, 2, 34, 56] as LinkedList;
println nodes instanceof java.util.LinkedList
///////////////////////////////////////////////////////////////////////////////////////////

Array :
  Array is fixed size , collection of items.

String[] strs = ['Hello', 'Hai'];
println strs
//def [] ints = [1,23]
def ints = [1, 23] as int[];
println ints instanceof java.util.ArrayList
println ints instanceof int[]

//Arrays : java style declaration
def mynumbers = new int[]{2, 45, 1, 2, 3};


Booleans and List && Array
...........................

//empty list ; no values
def emptyList = [];
//truth and falsy values in List

if (nodes) {
    println "Nodes Present"
} else {
    println("Nodes not Present")
}
if (emptyList) {
    println "Not Empty List"
} else {
    println("Empty  List")
}


def emptyArray = [] as int[];
if (emptyArray) {
    println "Not Empty Array"
} else {
    println("Empty  Array")
}
////////////////////////////////////////////////////////////////////////////////////////////
Map : Key -Value Pair Data Structure:
.....................................

Java :
HashMap map = new HashMap();
map.put(1,"Subramaian");
map.put(2,"Karthik");

In Groovy:

def map = [1:'subramanian',2:'Karthik']

def map = [1: 'Subramanian', 2: 'Ram', 3: 'Karthik']
println map;
println map.get(1)
println map instanceof java.util.Map;
println map instanceof java.util.LinkedHashMap;

//empty map declaration
def emptyMap = [:];
println(emptyMap)
//Truthy and falsy values in Map
if(map){
    println "Map Present"
}else{
    println "Map not present"
}

if(emptyMap){
    println "Map Present"
}else{
    println "Map not present"
}
/////////////////////////////////////////////////////////////////////////////////////////////
                                              Operators
//////////////////////////////////////////////////////////////////////////////////////////////

Arithmetic operators:
......................
+ - Addition
- - Substraction
* - multiplication
/ - division
% - remainder
** - power operator - groovy operator


Unary Operators:

 ++
 --
++a
a++
a--
--a

println "Arthimetic operators"

def a = 10
def b = 20;

println "Addition ${a + b}"
println "Substraction ${a - b}"
println "Multiplication ${a * b}"
println "Division ${a / b}"
println "Remainder ${a % b}"
println "Power of  ${a**2}"
println "Unary + ${a++}"
println "Unary + ${++a}"
/////////////////////////////////////////////////////////////////////////////////////////////

Assignment operators
.............................................................................................
//single assignment
def a = 10;
def b = 20;
println "$a $b";
//multiple assigment : javastyle
int s = 1, d = 80;
def x = 1, y = 2;
println "$x $y";
//multiple assignment : groovy style
def (x1, y1, de) = [10, 20, 9];
println "$x1 $y1 $de";

//mixed data type in one line
def (status, today, counter) = [true, "02-02-19", 1];
println "$status  $today  $counter"

//extra values are left
def (one, two) = [1, 2, 3, 4, 5];
println "$one $two";
//lesser values but extra variable and its value is null
def (xy, xz, xa) = [1, 3];
println "$xy $xz $xa";
//def (name,age,city); //error
def (name, age, city) = [];
println "$name $age $city"

Assignment and Artihmetic:
...........................

 def a =90;
 def res = a + 1
 def a+=3

+=
-=
*=
/=
%=
**=
//////////////////////////////////////////////////////////////////////////////////////////
 
Relational Operators: The Result would be boolean
/////////////////////

== equal
!= not equal - different
< lessthan
> greater than
<= less than or equal
>= greater than or equal

def a = 10;
def b = 10;
println a == b;
println a < b;
println a <= b;
println a > b;
println a >= b;
println a != b;
////////////////////////////////////////////////////////////////////////////////////////

Logical Operators: boolean result
..................

&&  - logical "and"
||  - logical "or"
!   - logical "not"

These operators works based on truth table

and
0 0 - 0
1 0  - 0
0 1  -1
1 1  -1

def isActive = true;
def isEnabled = true;
println " && => " + isActive && isEnabled; //true
println " || => " + isActive || isEnabled; //true
println " !  => " + !isEnabled; //false

def name = ""   //false
def city = "Coimbatore";  //true
println name && city; //?


def start = 0; //0 false
def stop = 10; //10 true
println start || stop; // true

def isEmpty;
println isEmpty;
println !isEmpty
isEmpty = "hello"
println !isEmpty
///////////////////////////////////////////////////////////////////////////////////////////

Bitwise and bit shift operators:
.................................

Bitwise operators are used to maniuplate bits - based on 2's compliement theories.

& - bit wise and
| - bit wise or
~  - bitwise negation

bit shit operators

<<  -left shift
>> -right shift
>>> - right shift unsigned.
////////////////////////////////////////////////////////////////////////////////////////////

Conditional Operators:
......................

1.not operator - !
2.Tenary operator - ?:
3.Elvis Operator  - ?

Elvis operator:
..............
The "Elvis operator" is a shortening of the ternary operator. One instance of where this is handy is for returning a 'sensible default' value if an expression resolves to false-ish

def a=0

 if a is true, print a's value , else assign our own default value.

?: =>Elvis operator

//Elvis operator is used to assign default values if a variable is false.

def counter; //null
//if counter is false,then initalize 1 else the value of the counter
println counter ?: 1;


//!
def myvar = true;
println !myvar;
//?:
//where ever if ..else lader you can replace with ?:
def a = 10;
def b = 20;
if (a == b) {
    println "Equal"
} else {
    println "Not equal"
}
a == b ? println("Equal") : println("Not Equal");
def result = a == b ? "Equal" : "Not Equal";
println result
def name = "subramanian";
def found = name ? "Name Found $name" : "Name not Found"
println found;
//////////////////////
def price;
//Using tenary
println price ? price : 10;
//Using elivs
println price ?: 10

def totalPrice = price?:10 * 100;
println "Total Price $totalPrice"

////////////////////////////////////////////////////////////////////////////////////////////

Regular Expression Operators:
.............................

Pattern Operator : ~
~/pattern/ ->Pattern

//~Pattern operator
def pattern = ~/\d+/
println pattern instanceof Pattern

Find operator:=~

Alternatively to building a pattern, you can directly use the find operator =~ to build a java.util.regex.Matcher instance

=~ ->Returns Matcher Instance

def text="mytext"
//=~ Find operator which returns Matcher
def matcher = (text =~/\d+/);
println matcher instanceof Matcher; 


Match operator:
..............

 ==~ Matcher Operator : returns boolean
 !=~ Matcher Operator : returns boolean
/////////////////////////////////////////////////////////////////////////////////////////////
Advanced Operators:
1.Spread Operator
2.Range Operator
3.Spaceship Operator
4.Subscript Operator
5.Identity Operator
6.Coercion Operator
7.Call Operator
8.Method Reference/ Pointer Operator 
9.Object Operators
   Safe navigation operators
   Direct field access operators
   Method pointer operators
   Method reference operators
/////////////////////////////////////////////////////////////////////////////////////////////

                                          Conditional Strucutures
/////////////////////////////////////////////////////////////////////////////////////////////

1. if/else
  Groovy supports if/else from java 

def isActive = true;

if (isActive) {
    println "Active"
} else {
    println "Not Active"
}

2.Switch...case
 
 Groovy switch case can handle any type of switch value and different kinds of matching can be performed.

def x = 1.23;
def result = "";

switch (x) {
    case "foo":
        result = "foo value"
        break
    case "bar":
        result = "bar value"
        break
    case 122:
        result = "some numbers"
        break
    case true:
        result = "some boolean"
        break
    case Integer:
        result = "Integer value"
        break
    case ~/fo*/:
        result = "Regular expression value"
        break
    case Number:
        result = "Number value"
        break;
        defalut:
        result = "No match found"
}
println result;
/////////////////////////////////////////////////////////////////////////////////////////////
				Iterators - Loops
/////////////////////////////////////////////////////////////////////////////////////////////

Groovy supports java/c style loop

for,while,do..while
//classic for loop
for (int i = 0; i < 10; i++) {
    println i;
}
for (def i = 0; i < 10; i++) {
    println i;
}
//classic while loop
def x = 0
def y = 5
while (y-- > 0) {
    x++
    println "Y $y"
}
println x;
//do ..while
def counter = 5;
def fact = 1;
do {
    fact *= counter--
} while (counter > 1)
println fact
..............................................................................................

Coding Challanges:
..................

Q:1.find even numbers from 0 to 1000 range.


Q.2.find Grade for given score

 score is greater than 95 - A

 80 tO 95 - Grade B

 60 to 80 -Grade C
 
 50 TO 60 - Grade D
 
 less THAN 50 - F 

 /////////////////////////////////////////////////////////////////////////////////////

Groovy Script Programming:
..........................

-collection of variables and methods(functions).

How scripts are working?

 When we write script , groovy creates a class "ScriptClass" , will have main method and run method.
 The name of the script file  will go as name of the script class name.

eg:

Written by you?

 HelloWorld.groovy

 println "Hello Script"

Groovy will write like below

class HelloWorld extends Script{

    //method called run
    def run(){
      println "Hello Script"
   }

 
 static void main(String[]args){
  
      InvokerHelper.runScript(HelloWorld,args)
 }

}
/////////////////////////////////////////////////////////////////////////////////////////

methods:
........

-methods are going to group biz/application logic.


Syntax:

 1.static typed syntax ; looks like a java syntax

   returntype methodName(args){
     //method body
     return statement
   }
   void sayHello(){ 


   }
2. dynamic typed syntax

    def methodName(args){
      //method body
    }

MethodSimple.groovy

//methods simple

//static type
//mehtod declaration
void sayHello() {
    println "Hello";
}
//calling method
sayHello();

script class and methods:
.........................
-all methods will go inside script class as instance methods of script class
-methods invocation will go inside run method.

class MethodSimple extends Script{

      void sayHello() {
           println "Hello";
      }

    //method called run
     def run(){
         sayHello();
     }

 
 static void main(String[]args){
  
      InvokerHelper.runScript(HelloWorld,args)
 }

}

/////////////////////////////////////////////////////////////////////////////////////////////

methods with return type and args:
..................................

//methods simple

//static type
//mehtod declaration
void sayHello() {
    println "Hello";
}
//calling method
sayHello();

String sayHai(String name) {
    return "Hai $name"
}

println("${sayHai('Subramanian')}");

def mymethod() {
    println 'mymehtod';
}

mymethod();
///////////////////////////////////////////////////////////////////////////////////////////
Method flavours:Args:
.....................

args; receving
parameters : passing


-When compare to java, groovy allows to skip passing parameters. 
if you skip the value, the variable will hold "null" value.


def sayHello(String name) {
    println("$name");
}
sayHello('Subramanian');  => Subramanian
sayHello(); => null

Default values:
...............
 if you dont supply parameter, the groovy initalize the default values.

def sayHello(String name = 'defaultName') {
    println("${name.toUpperCase()}");
}

sayHello('Subramanian');
sayHello();

def add(int a = 0, int b = 0) {
    int result = a + b;
    println "The Add Result is $result";
}

add(10, 10)
add()

def doStuff(def x, def y) {
    int result = x + y;
    println "The DoStuff Result is $result";
}

doStuff(10, 10);
doStuff(78.9, 89.90)
//doStuff(true,90.78) : this produces runtime error;
//////////////////////////////////////////////////////////////////////////////////////////

Var -Args : Variable Args:
.........................
 what if i want a method, that method must take n-number of args.
 What if i pass more parameters, but i have less args.

type ...args
//doStuff(true,90.78) : this produces runtime error;
def logger(String ... message) {
    println message;
}

logger('hello'); //single parameter
logger('hello','hai'); //2 parameter
logger('hello','greetings','welcome'); //3 parameter
////////////////////////////////////////////////////////////////////////////////////////////

Without type keywords or def keywords

//def doSomething(def x){
//    
//}
//def doSomething(String x){
//
//}
def doSomething(x = 0) {
    pritln x
}

doSomething(1000)

////////////////////////////////////////////////////////////////////////////////////////////

Method Return values:
....................

type method(){}

def method(){}

String sayHello() {
    return 'Hello';
}

String result = sayHello();
println result;
println sayHello();

int add() {
    return 10 + 10;
    //  return "hello";
}

println add();

def sayHai() {
    return "Hello"
    //return 100;
}

println sayHai();

******************************************************************************************
Note:
In groovy , return statement is optional, not necessary, by default every method returns some
value , whether the return statement is present or not.

"Last line of method , will be return value";


String sayHello() {
    return 'Hello';
}

String result = sayHello();
println result;
println sayHello();

int add() {
    return 10 + 10;
    //  return "hello";
}

println add();

def sayHai() {
    return "Hello"
    //return 100;
}

println sayHai();
////////////////////////////////////////////////////////////////////////////////////////////////////

def getCount() {
    200; // return 200
}

println getCount()

def calculate() {
    10 + 10;
    20 + 20;
    50 + 50;
}

println(calculate())

def multiply(int a = 0, int b = 0) {
    println "multiply";
    def result = a * b;
    result * 10;
}

println(multiply(23, 89))
println(multiply()) // result

double multiply_1(int a = 0, int b = 0) {
    println "multiply";
    def result = a * b;
    result * 10;
}

println(multiply_1(23, 89))
println(multiply_1()) // result

void multiply_2(int a = 0, int b = 0) {
    println "multiply";
    def result = a * b;
    result * 10;
}

println(multiply_2(23, 89))
println(multiply_2()) // result // would be null

/////////////////////////////////////////////////////////////////////////////////////////////
def login(String userName = "admin", String password = "admin") {
    userName.equals("admin") && password.equals("admin");
}

def status;
status = login('guest', 'guest') ? 'Login Success' : 'Login failed';
println status
status = login() ? 'Login Success' : 'Login failed';
println status;
///////////////////////////////**********///////////////////////////////////////////////////
                    Object oriented Programming in Groovy
////////////////////////////////////////////////////////////////////////////////////////////
Object oriented Concepts:
1.Abstraction
2.Encapsulation
3.Modularity
4.Hierachy
5.Typing
6.Persistency
7.Concurrency

////////////////////////////////////////////////////////////////////////////////////////////

Abstraction:
  High level representation of domains in software
  In Programming languages abstraction is implemented via "classes , interfaces"...

class:

1. class is used to organize variables and methods under single unit.
    variables represent data, methods represent how to operate on that data.
2. class is template for a problem domain we call object.

classes are in java language:

1.class is used to represent object template.
2.class contains variables and methods
3.class can also contain another class,interfaces ; inner classes
4.Every java program must start with class definition only.
5.Every program can have mulitple java classes , but recommended is only one class per   file/program
6.Every java program must have main method.

Objects:

1.Runtime representation of class we call "Object"
2.Object means , memory representation of class.
3.We can create more objects from a single class, but each object has its own memory address
4.Object is pointed by a variable called "reference variable" ; pointer to object
5.object contains methods, and variables called instance members.


Steps:

1.declare class

package com.microgenesis.oo;

public class HelloWorld {
    public String sayHello(String name) {
        return "Hello " + name;
    }
}

2.Create Object - Allocate Memory for a class.

 You can create object for any class any where in the application.

here i will show you  , in main method.

 HelloWorld hello      =          new         HelloWorld();
   |         |         |           |             |
 Type     Reference assigment  memory         constructor call - method call
          Variable  operator   allocation
                               operator


package com.microgenesis.oo;

public class HelloMain {
    public static void main(String[] args) {
        HelloWorld hello = new HelloWorld();
        String result = hello.sayHello("Subramanian");
        System.out.println(result);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

class declaration types:

1.The class contains apis  - Service classes.
2.The class contains apis to interact with databases - Repository classes/DAO Classes
3.The class contains web end points - Controllers
4.The class contains only data - Entity classes/ Bean
5.The class contains global data  -  class with static data.

////////////////////////////////////////////////////////////////////////////////////////////

Step 1:
Entity
Product.java
package com.microgenesis.oo;

//Entity class ; Which reprents data pointer
public class Product {
    private int id;
    private String productName;
    private double price;
    private int qty;
    private boolean inStock;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getProductName() {
        return productName;
    }

    public void setProductName(String productName) {
        this.productName = productName;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getQty() {
        return qty;
    }

    public void setQty(int qty) {
        this.qty = qty;
    }

    public boolean isInStock() {
        return inStock;
    }

    public void setInStock(boolean inStock) {
        this.inStock = inStock;
    }


}

ProductRepository.java
package com.microgenesis.oo;

import java.util.Arrays;
import java.util.List;

public class ProductRepository {
    public List<Product> findAll() {
        Product product1 = new Product();
        product1.setId(1);
        product1.setProductName("Phone");
        product1.setInStock(true);
        product1.setPrice(23.89);
        product1.setQty(100);

        Product product2 = new Product();
        product2.setId(2);
        product2.setProductName("TV");
        product2.setInStock(true);
        product2.setPrice(29993.89);
        product2.setQty(10000);

        return Arrays.asList(product1, product2);
    }
}

ProductService.java
package com.microgenesis.oo;

import java.util.List;

public class ProductService {
    //declare variable
    private ProductRepository repository = new ProductRepository();

    public List<Product> findAll() {
        return repository.findAll();
    }
}

Application.java
package com.microgenesis.oo;

import java.util.List;

public class Application {
    public static void main(String[] args) {
        ProductService service = new ProductService();
        List<Product> products = service.findAll();
        for (Product product : products) {
            System.out.println(product.getId() + " " + product.getProductName());
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Java Beans:
...........

-It is a standard  or spec for declaring a class and create object.

Rules:

1.class must be declared with public keyword
 
  public class Customer{}

2. class must have instance variables 

   public class Customer {
          int id;
          String name; 
   }
3. instance variables must be marked with private keyword

   public class Customer {
          private int id;
          private String name; 
   }

 - instance variables hold data of object like id,name.

 How to initalize the data?

 Ways:
3.1.direct initalization
  private int id =1;
  private String name ="Subramanian"
 which is not standard way.

3.2.after object creation via reference variable
public class Customer {
    int id;
    String name;
}

Customer customer = new Customer();
        customer.id =1;
        customer.name ="Subramanian";
        System.out.println(customer.id + " " + customer.name);

 it is valid but not recommended as per java bean standards.

4.we must introduce methods to initalize and read instance variables
  -methods : accessors and mutatators ; setters and getters.

set methods - to initalize the data
get methods - to read data.

set method rules:

  public void setVariableName(datatype variableName){

     this.variableName =variableName
  }
  public void setId(int id) {
        this.id = id;
    }
    public void setName(String name) {
        this.name = name;
    }

getter:
 
  public returnType getVariable(){
      return variable;
  }
package com.microgenesis.oo;

public class Customer {
    private int id;
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

4.1.data can initalized without setter methods

 via constructors

constructors:
  
-It is special method
-to initlize instance variables during object creation.

constructors offer various ways to initalize object.

package com.microgenesis.oo;

public class Customer {
    private int id;
    private String name;

    //default constructor
    public Customer() {

    }

    //args constructors;
    //only id
    public Customer(int id) {
        this.id = id;
    }

    public Customer(String name) {
        this.name = name;
    }

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.microgenesis.oo;

public class JavaBeanSpec {
    public static void main(String[] args) {
        Customer customer = new Customer();

//        customer.id =1;
//        customer.name ="Subramanian";
//        System.out.println(customer.id + " " + customer.name);
        customer.setId(12);
        customer.setName("Subramanian");
        System.out.println(customer.getId() + " " + customer.getName());

        //args constructors
        //single id
        Customer customer1 = new Customer(125);
        customer1.setName("foo");
        System.out.println(customer1.getId() + " " + customer1.getName());

        Customer customer2 = new Customer("bar");
        customer2.setId(1000);
        System.out.println(customer2.getId() + " " + customer2.getName());

        Customer customer3 = new Customer(7888,"barfoo");
        System.out.println(customer3.getId() + " " + customer3.getName());



    }
}
/////////////////////////////////////////////////////////////////////////////////////

setters vs constructors:

 Both recommened:

1.Use setter once object is created. lazy initalization
2.Use constructor during object creation; Eagar intialization
/////////////////////////////////////////////////////////////////////////////////////

Groovy and Object Oriented Programming:

1.Groovy uses Groovy Standards
   ->Groovy Bean standards


1.declare class
2.create object

class:

1.Groovy classes are very similar to Java classes, and are compatible with Java ones at JVM level.

2.They may have methods, fields and properties (think JavaBean properties but with less boilerplate).

3.Classes and class members can have the same modifiers (public, protected, private, static, etc) as in Java with some minor differences at the source level


The key differences between Groovy classes and their Java counterparts are:

1.Classes or methods with no visibility modifier are automatically public (a special annotation can be used to achieve package private visibility).

2.Fields with no visibility modifier are turned into properties automatically, which results in less verbose code, since explicit getter and setter methods aren’t needed.

3.Classes do not need to have the same base name as their source file definitions but it is highly recommended in most scenarios

4.One source file may contain one or more classes (but if a file contains any code not in a class, it is considered a script). Scripts are just classes with some special conventions and will have the same name as their source file (so don’t include a class definition within a script having the same name as the script source file).


Fields  Declaration Rules:

1.fields must be declared without any explicit modifer
2.fields must have strong typing not def keyword
3.As soon as you declare fields based on the above rules
  groovy will generate setter and getter methods.



Lets code:

1.create groovy class and create object.

package com.microgenesis.groovy.beans

class User {
    //in groovy theses variables scope is public by default
    int userId;
    String userName;
    String password;
}

import com.microgenesis.groovy.beans.HelloWord
import com.microgenesis.groovy.beans.User

//Strong typing
HelloWord helloWord = new HelloWord();
println(helloWord.sayHello());
println(helloWord.sayHelloAgain("Subramanian"))

def helloWorld1 = new HelloWord();
println(helloWorld1.sayHello());
println(helloWorld1.sayHelloAgain("Ram"))

//Groovy beans
User user = new User();
//calling setters
user.userId = 1; // triggers setters, no need of calling setters manually
user.userName = "Subramanian"; //
user.password = "admin"
//getters
println "User Info ${user.userId} ${user.userName} ${user.password}"

//constructors: id,name,password :groovy uses map syntax to create constructors dynamically
//key:value ; key-instance variable; value ; variable value
User user1 = new User(userId: 1, userName: 'root', password: 'super');
println "User Info  ${user1.userId} ${user1.userName} ${user1.password}"
//////////////////////////////////////////////////////////////////////////////////////////////

Object Operators:
................

1.Direct field access operator:

 It is used to access fields

field:
  - It is an instance variable declared inside class


"." - field access operator.
    internally triggers getter
".@" - field access operator.
    if you want to access without getter.



class Person {
    int id;
}

def person = new Person(id:100);
println person.id;

person.id ----calls person.getId() => which calls getter method

println person.@id -Which access id property directly
/////////////////////////////////////////////////////////////////////////////////////////////

Default values for an Object:
.............................

if you declare any variable whether it is primitive or reference inside a class.
  Those variables are called as "instance variables".

if you declare any variable whether it is primitive or reference inside a class with static keyword.
  Those variables are called as "class  variables". static String varName=value

Any variable has default value:

integer family
  0
floating family
 0.0
boolean family
 false
Reference types - String,Employee....
 null

class Person {
    int id;
    String name;
    boolean  isActive;
    double pointers;

}

def person = new Person();
println person.id;
println person.@id
println person.name
println person.isActive
println person.pointers

output:

0
0
null
false
0.0
/////////////////////////////////////////////////////////////////////////////////////////////
How to know the Runtime information obout a class?


def person = new Person();
println person.getClass();

output:
class com.microgenesis.groovy.beans.Person


def person1= null;
println person1.getClass();

class org.codehaus.groovy.runtime.NullObject

null:
 means the reference variable is not pointing object of some type.

NullPointerException:

 It is runtime error, which is thrown when ever you access object fields and methods

if object not assigned

Person person1= null;
println person1.getClass();
println person1.name

here person1 variable does hot have any object store, so that , person1.name will throw the following error.

Caught: java.lang.NullPointerException: Cannot get property 'name' on null object
java.lang.NullPointerException: Cannot get property 'name' on null object
	at ObjectOperators.run(ObjectOperators.groovy:13)

How to safely avoid NullpointerException?

Groovy provides an operator called 

 "safe navigation operator":
      ?.

eg:
  person1?.name

//Person person1=new Person(name:'Subramanian');
Person person1 = null;
println person1.getClass();
//println person1.name
println person1?.name

if (person1?.name) {
    println("Name found")
} else {
    println "Name not found!"
}
def res = person1?.name ? "Name Found" : "Name Not found!"
println res;
////////////////////////////////////////////////////////////////////////////////////////////

Method Pointer Operator:
.........................
The method pointer operator (.&) can be used to store a reference to a method in a variable.
in order to call it later.


class Person {
    int id;
    String name;
    boolean isActive;
    double pointers;

    def save() {
        "Save method is called"
    }

}

//Method pointer Operator
Person person2 = new Person();
println person2.save() //direct call
//store method pointer into a variable
def saveDummy = person2.&save
println saveDummy(); 
//////////////////////////////////////////////////////////////////////////////////////////

Method Reference Operator:
..........................

The Latest groovy (groovy version 3) supports java 8 method reference syntax.

The operator is "::" - method reference operator.

class Task {
    private void startMicroTask() {
        println(Thread.currentThread().getName());
    }
    public void startTask() {
        Thread thread = null;
        thread = new Thread(new Runnable() {
            @Override
            void run() {
                //thread logic
                println Thread.currentThread().getName();
            }
        });
        thread.start();
        //method reference operator to eleminate the above code.
        thread = new Thread(this::startMicroTask)
        thread.start();

    }

}
Task task = new Task();
task.startTask();
////////////////////////////////////////////////////////////////////////////////////////////

Spread Operator:
................
Lets say you have list of Cars(object), you want to access a particular field.

*. -  Spread Operator
 

Car.groovy

class Car {
    String make;
    String model;
}


def cars = [
        new Car(make: 'Renault', model: '2020'),
        new Car(make: 'Maruthi', model: 'Alto')
]
def makes = cars*.make;
println makes
//////////////////////////////////////////////////////////////////////////////////////////

Object DeStructuring:
 
 Extracting object properties.

Rules;
-in order to implement object destructuring, getAt method must be given
-returns variable type /def 
-takes index as arg
-write a logic to assign index  based properties


class Coordinates {
    double latitutde;
    double longitude;
    //object destrucing api
    def getAt(int idx) {
        if (idx == 0) latitutde
        else if (idx == 1) longitude
        else throw new Exception("Property not found")
    }
}
def coordinates = new Coordinates(latitutde: 34.89, longitude: 1.2);
//println("${coordinates.latitutde}  ${coordinates.longitude} ")
def (lat, lng) = coordinates;
println("${lat}  ${lng} ")
//////////////////////////////////////////////////////////////////////////////////////////////

Methods
......
-method defintions
-method parameters
  -named parameters
  -positional parameters
  -default ars
  -var args

package com.microgenesis.oo

class MyMethods {
    //instance methods
    def someMethod() {
        'My return value'
    }

    String someMethod2() {
        'Method 2 return value'
    }

    def someParam(def param1) {
        param1
    }

    def someStringParam(String param2) {
        param2
    }

    def someParamNew(param3) {
        param3
    }
    //positional parameters
    def add(int a = 1, String foo = "hello") {
        println "$a $foo";
    }

    //Named Parameters + Positional Parameter
    def bar(Map args, Integer bar = 0) {
        println "${args.name}  ${args.city} ${bar}"
    }

}

def mymethods = new MyMethods();

println mymethods.someParamNew('hello')
//mymethods.add("hello",67)
mymethods.add(67, "hello")
mymethods.bar(name: 'subramaian', city: 'Coimbatore', 90)
mymethods.bar(city: 'Chennai', name: 'Subramanian')
mymethods.bar(23, city: 'Chennai', name: 'Subramanian')
//////////////////////////////////////////////////////////////////////////////////////////////

                                     Encapsulation
//////////////////////////////////////////////////////////////////////////////////////////////

What is encapuslation?

 It is a feature of OO, talks about , how to prevent code sharing.

What is code :
  collection of classes
  class is having fields and methods, constructors

In large application , we create many classes, we need to set some of rules how to share code.

How to restrict code access?

 java/groovy provides keywords 
   -private,default,public,protected

private - means no body can access expect the current class
 private is used for instance variables and instance methods.

In groovy:
 private variables are not recommended to be treated as object fields.

if you declare private, groovy wont generate setter and getters.
private variables are by default converted into public.
private methods are by default converted into public.

public:
 it is default modifier , no need to tell 

if you tell, no setters and getters will be generated, if dont want setter and getter 
you use public keyword.

default: no modifer is told

     String city; - public 

protected: used inside inheritance


classes are by default public without public keyword

User.groovy  - scope is public
class User{}

User.java
class User {} - scope is default-package level
.............................................................................................
                                  Hierachy
............................................................................................

Talks about Relationship.

 -Object Relationships

-HAS-A 
-IS-A - inheritance



HAS-A

Address.groovy
package com.microgenesis.oo.hasa

class Address {
      String street;
      String city;
}

Guest.groovy
package com.microgenesis.oo.hasa

class Guest {
    int id;
    String name;
    //has-a relationship ; Customer has a address
    Address address;
}


Dependance injection:

Binding objects among them.

we need to bind address with customer.

How we can bind objects?

-setter injection/binding
-constructor injection/binding



import com.microgenesis.oo.hasa.Address
import com.microgenesis.oo.hasa.Guest

//setters
Address a = new Address();
a.street = '10th street';
a.city = 'Coimbatore';
Guest guest = new Guest();
guest.id = 1000;
guest.name = "subramanian";
//setter injection
guest.address = a
println "Guest Information"
println "ID ${guest.id}"
println "Name ${guest.name}"
println "Address ${guest.address.city} ${guest.address.street}"

//consturctors injection

Guest guest1 = new Guest(id: 12, name: 'Subramanian',
        address: new Address(city: 'Coimbatore', street: '10th Street'));
println "Guest Information"
println "ID ${guest1.id}"
println "Name ${guest1.name}"
println "Address ${guest1.address.city} ${guest1.address.street}"

///////////////////////////////////////////////////////////////////////////////////////////

IS-A : inheritance:

Objective of inhiertance:

-To share code across the common classes: to avoid duplicate code.

Implementation:

- classes
   -regular/concrete classes
   -Abstract classes
- interfaces
- trait -  only in groovy


inheritance: code reuse
.......................

1.base class / super class/ parent class
2.child class/sub class

inheritance is class level, inheritance happens during compile time.

java supports single inheritance
java supports multi level inhertiance via interfaces.

groovy supports both.

Implementation:
1.concrete class 

extends - key word is used to connect classes.

as soon as two classes are connected code can be shared- data,methods.


Vehicle.groovy

package com.microgenesis.oo.isa

class Vehicle {
    def startEngine() {
        "Vehicle engin starts";
    }
}

Car.groovy

package com.microgenesis.oo.isa

class Car extends Vehicle {
}

Bus.groovy

package com.microgenesis.oo.isa

class Bus extends Vehicle{
}


Inheritance.groovy
import com.microgenesis.oo.isa.Car

def car = new Car()
println car.startEngine()


/////////////////////////////////////////////////////////////////////////////////////////

Overriding:

 The over ride the base class method in dervied class.

When ever we call a method , the Runtime sees a dervied class only. if method found in the 
dervied class, then that method will be called.


Use case : source code

Vehicle.groovy

class Vehicle {
    def startEngine() {
        "Vehicle engine starts";
    }
}

Car.groovy
class Car extends Vehicle {
}        
                       |
def car = new Car();
car.startEngine() ------

 here startEngine is not present in dervied class. but how it is called.


In the source code , no method present,

After compilation, the compiler will generate a code like below

Vehicle.class

class Vehicle {
    def startEngine() {
        "Vehicle engine starts";
    }
}

Car.class
class Car extends Vehicle {
   def startEngine() {
        super.startEngine()
    }
}   
def car = new Car();
car.startEngine()

/////////////////////////////////////////////////////////////////////////////////////////

Pointers: reference variables ; pointer to object
..............................

HelloWorld hello = new HelloWord();

hello - reference variable

Types of reference variables:

1.explicit reference variable;

 -variables are defined by us.
eg
HelloWorld hello = new HelloWord();

hello - Explicit reference variable

2.Implicit reference variable
 
 Variables are defined by jvm .

"this":
  -It is variableName
  -It points the Object
  -It points the Object itself
  -this variable is created during object creation, points itself
  -every object has hidden implicit this pointer.

"super"
   -It is variableName
   -It POints the Object
   -It points the Parent Object.
   -super variable is created during object creation, points Parent always.
  -every object has hidden implicit this pointer.



package com.microgenesis.oo.isa

class Account {

    def deposit() {
        1000.80;
    }
}
	
package com.microgenesis.oo.isa

class SavingsAccount extends Account {
    //overriding
    def deposit() {
        10800.6777 + super.deposit()
    }
}

SavingsAccount savingsAccount = new SavingsAccount();
println(savingsAccount.deposit())
/////////////////////////////////////////////////////////////////////////////////////////////

                                                 Typing
//////////////////////////////////////////////////////////////////////////////////////////////

Typing talks about Object types.

-Concrete Type 
-Super type


-Concrete Type 
 
Type of the variable and value of the variable belongs to same datatype

 Left == Right
 SavingsACccount sb  =new SavingsAccount()
 
class SavingsAccount{}

SavingsAccount sb = new SavingsAccount()
  |             |
Type          reference variable


Super Type /Program to super type.
..................................

-The type of reference variable can be super class.

class Account {

}
class SavingsAccount extends Account {
    
}

object creation syntax

1.SavingsAccount sb = new SavingsAccount();

//Program to super type.

2.Account sb = new SavingsAccount();

3.Object sb = new SavingsAccount();

////////////////////////////////////////////////////////////////////////////////////////////

Polymorphsim:
.............
 Variable(reference) binding with value

 int a =10 ===> binding ; the variable binds a value of int type
 
 Dog dog = new Dog() ==> binding; the variable binds a value(Object) of Dog type.
 dog.eat() ===> value binding; method binding

During compile time, the type of variable and binding evaulated, where as runtime, the value
is assigned.

1.Variable with type binding happens during compile time.

  Animal a =new Dog();
  a.eat();

  During compile time, "The compiler looks always left side"

2.Value binding with variable happens during runtime.

  Animal a =new Dog();
  a.eat();
   
   During runtime, the Runtime(jvm) always looks right right

What if child class has extra method , Using parent type, how to compile?

    Animal animal = new Dog();
    animal.bark(); //compile time error

How to fix compile runtime?

Type casting:

    int a =1000;
    byte b = (byte)a;
    
int is big
byte is smaller
we have casted big to small.

Similarly in reference types

ParentType is big
Child type is small.

        Animal animal = new Dog();
        animal.eat();
        Dog mydog = (Dog) animal;
        mydog.bark();
////////////////////////////////////////////////////////////////////////////////////////////

Every java class /Groovy class has by default has parent class "java.lang.Object" / "groovy.lang.Object"


Greeter.java
public class Greeter{

}
|
after compilation

Greeter.class
public class Greeter extends java.lang.Object{

}

Animal.java
public class Animal{

}
Dog.java
public class Dog extends Animal{

}

|
after compilation
Animal.class
public class Animal extends java.lang.Object{

}
Dog.class
public class Dog extends Animal{

}

"The type of variable can be Object"
      ///Object
        Object animalObj = new Dog();
        Dog mydogObj = (Dog) animalObj;
        mydogObj.bark();
        mydogObj.eat();
/////////////////////////////////////////////////////////////////////////////////////////////

Groovy and Program to Super Type: How groovy achives dynamic typing
...................................................................

def i = 100;

Ways:

 Integer i = new Integer(100); 

 Number i =new Integer(100)
 
 Object i = new Integer(100)


eg

 Integer i = new Integer(100);
        System.out.println(i.intValue());

        Number i1 = new Integer(100);
        System.out.println(i1.intValue());

Object

        Object i2 = null;
        i2 = new Integer(100);
        Integer myInteger = (Integer) i2;
        System.out.println(myInteger.intValue());
        i2 = new String("Hello");
        System.out.println(i2.toString());
/////////////////////////////////////////////////////////////////////////////////////////////
  
         Groovy uses the type "Object" as type for all varibale declaration

def i = 100; ====>def is replaced by "Object"

println i + " " + i.getClass();
i = "Hello";
println i + " " + i.getClass();

groovy takes cares of Casting for us.
 Object a;
def a =10 // a= new Integer
a=90.89   // a  = new BigDecimal
a="Test"  // a =new String()
a=new Customer = a = new Customer()

////////////////////////////////////////////////////////////////////////////////////////////

interface,trait,abstract methods,abstract class


interface based inheritance:
............................

What is interface?
 
 interface is similar to class .

Why interface for inheritance instead of class?

Inheritance is creating family of classes.

if you sharing data with in family : classes are suitable

if you are sharing data across the family : interfaces are suitable.


Family of classes:
..................

Group classes based on domain.

Account,Customer,Employee


Account Related classes
 SavingsAccount,LoanAccount,CurrentAccount

Customer related
Corporate,Individual,OtherBanks


/////////////////////////////////////////////////////////////////////////////////////////

Interfaces:

 -interfaces are classes;
 -interfaces can have abstract methods.

abstract method:
 no implementation is provided. implementation provided by implementators who inherits the interfaces.

- interface can inherit other interfaces

- a class should implement interface
- a class can implement multiple interfaces.
- Interface can act as super type.


interface is keyword
implments is keyword


Flyable.groovy

package com.microgenesis.oo.isa.inter

interface Flyable {
    //abstract methods
    //public void abstract fly();
    def fly(); //abstract method
}

AirPlane.groovy
package com.microgenesis.oo.isa.inter

class AirPlane implements Flyable {
    @Override
    def fly() {
        'AirPlane flies'
    }
}

Bird.groovy
package com.microgenesis.oo.isa.inter

class Bird implements Flyable {
    @Override
    def fly() {
        'Bird flies'
    }
    def eat(){
        'Bird can eat'
    }
}


SpiderMan.groovy
package com.microgenesis.oo.isa.inter

class SpiderMan implements Flyable {
    @Override
    def fly() {
        'SpiderMan flies'
    }
}

interfacedemo.groovy
import com.microgenesis.oo.isa.inter.AirPlane
import com.microgenesis.oo.isa.inter.Bird
import com.microgenesis.oo.isa.inter.SpiderMan

//Flyable flyable = null;
//Object flyable=null;
def flyable = null;
flyable = new Bird();
println(flyable.fly())
println(flyable.eat())
flyable = new AirPlane();
println(flyable.fly())

flyable = new SpiderMan();
println(flyable.fly())
///////////////////////////////////////////////////////////////////////////////////////////

Multiple inheritance:

package com.microgenesis.oo.isa.inter

interface Init {
  def init();
}

package com.microgenesis.oo.isa.inter

interface Destroy {
    def destroy();
}
package com.microgenesis.oo.isa.inter

class Computer implements Init, Destroy {
    @Override
    def init() {
        'Init'
    }

    @Override
    def destroy() {
        'Destory'
    }
}

import com.microgenesis.oo.isa.inter.Computer

def computer = new Computer();
println computer.init()
println computer.destroy()
/////////////////////////////////////////////////////////////////////////////////////////

Interface and multiple inheritance

-An interface can extends other interfaces,not implement.


package com.microgenesis.oo.isa.inter

interface Start {
  def start();
}

package com.microgenesis.oo.isa.inter

interface Init extends Start {
  def init();
}

package com.microgenesis.oo.isa.inter

class Computer implements Init, Destroy {
    @Override
    def init() {
        'Init'
    }

    @Override
    def start() {
        'start'
    }

    @Override
    def destroy() {
        'Destory'
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

                                    Traits
/////////////////////////////////////////////////////////////////////////////////////////////

What is trait?
 Trait is similar as interface but very advanced interfaces.

drawbacks of interfcases

1.interfaces cant have implementation; but this feature added in java 8.


Traits are a structural construct of the language which allows

 -composition of behaviours
 -runtime implementation of interfaces
 -overriding
 -supports static typing/compilation

Trait declaration:

Flyable.groovy
package com.microgenesis.oo.isa.traits

trait Flyable {
    //method implemenation
    String fly() {
        'I am flying'
    }
}
package com.microgenesis.oo.isa.traits

class Bird implements  Flyable{
}
//basic trait: default implementation
def bird = null;
bird = new Bird();
println(bird.fly())
//////////////////////////////////////////////////////////////////////////////////////////

Trait Methods:
.............
-can have public methods - normal methods
-can have abstract methods
-private methods

package com.microgenesis.oo.isa.traits

trait Greetable {
    abstract String name();
    String greeting() {
        "Hello ${name()}"
    }
}
class Person implements Greetable {
    @Override
    String name() {
        'Subramanian'
    }
}
def greetings= new Person();
println(greetings.greeting())


private methods are allowed inside trait:
..........................................

trait Greetable {
    abstract String name();

    private String getMessage() {
        'Hello'
    }

    String greeting() {
        "${getMessage()} ${name()} "
    }
}

class Person implements Greetable {
    @Override
    String name() {
        'Subramanian'
    }
}
def greetings= new Person();
println(greetings.greeting())
/////////////////////////////////////////////////////////////////////////////////////////

Traits and interfaces mixing:
............................

package com.microgenesis.oo.isa.traits

interface Named {
   String name();
}


package com.microgenesis.oo.isa.traits

trait Greetable implements Named {
    //abstract String name();
    private String getMessage() {
        'Hello'
    }
    @Override
    String name() {
        'Subramanian'
    }
    String greeting() {
        "${getMessage()} ${name()} "
    }
}

package com.microgenesis.oo.isa.traits

class Person implements Greetable {
//    @Override
//    String name() {
//        'Subramanian'
//    }
}
////////////////////////////////////////////////////////////////////////////////////////////

Properties ,Fields and Traits
 Traits properties -instance variables like classes : public variables
 Traits fields  -  intance variabels like classes ; private variables
 	

package com.microgenesis.oo.isa.traits

trait Age {
   int age; //properties
}

class Person implements Greetable ,Age  {

}

def greetings= new Person(age:18);
println(greetings.greeting() + " " + greetings.age)

package com.microgenesis.oo.isa.traits

trait Age {
    private int counter = 0;
    int age; //properties
    int getCounter() {
        counter += 1;
        counter;
    }

}

def greetings= new Person(age:18);
println(greetings.greeting() + " " + greetings.age)
println(greetings.getCounter())
println(greetings.getCounter())
/////////////////////////////////////////////////////////////////////////////////////////////

An trait can extend other traits:
.................................

package com.microgenesis.oo.isa.traits.more

trait Named {
  String name;
}
package com.microgenesis.oo.isa.traits.more

trait Greet extends Named {
    def sayHello() {
        "Hello ${name}"
    }
}

package com.microgenesis.oo.isa.traits.more

class Person implements  Greet{
}

import com.microgenesis.oo.isa.traits.more.Person

def person = new Person(name:'Subramanian');
println(person.sayHello())
//////////////////////////////////////////////////////////////////////////////////////////////

Diamond Problem,Multiple Inheritance conflicts:



package com.microgenesis.oo.isa.traits.more

trait A {
  String exec(){
      'A'
  }
}
package com.microgenesis.oo.isa.traits.more

trait B {
    String exec(){
        'B'
    }
}
package com.microgenesis.oo.isa.traits.more

class C implements A, B {
}

def result = new C();
println(result.exec())

The result here is "B".

How?
  The default behaviour is that the method from the last declared trait in the implement clause wins

if you want to change this without changing the order of implementation

class C implements A,B {
    @Override
    String exec() {
        A.super.exec()
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Trait Attachmement with a Class without using implements keyword: Runtime implemenation of traits:
..........................................................................................

package com.microgenesis.oo.isa.traits.more

trait Advanced {
    String doStuff() {
        'I am Dynamic'
    }
}


package com.microgenesis.oo.isa.traits.more

class Machine {
}

def machine =new Machine() as Advanced;
println machine.doStuff()
//////////////////////////////////////////////////////////////////////////////////////////

What if more traits if you want to attach:
....................................

package com.microgenesis.oo.isa.traits.more

trait StartMachine {
  String startMachine(){
      'Start machine'
  }
}

package com.microgenesis.oo.isa.traits.more

trait Advanced {
    String doStuff() {
        'I am Dynamic'
    }
}
 

def mymachine = new Machine();
def newMachine = mymachine.withTraits Advanced, StartMachine
println(newMachine.doStuff())
println(newMachine.startMachine())
////////////////////////////////////////////////////////////////////////////////////////////

Abstract classes:
.................

-concret classes are used to group common behaviours with implemenation
-interfaces are used to group common behaviours for different classes with abstract methods
-traits are used to group common behaviours for different classes with all features.

Abstract classes:
 -common behaviour for group of classes with concrete and abstract methods.


package com.microgenesis.oo.abs

abstract class Bird {
    abstract def eat();
    //non abstract methods
    def saveBirds() {
        'Save Birds from Global Warming!!!'
    }
}

package com.microgenesis.oo.abs

class Dove extends Bird {
    @Override
    def eat() {
        'Dove eats Nuts'
    }
}
package com.microgenesis.oo.abs

class Crow extends Bird {
    @Override
    def eat() {
        'Crow eats all'
    }
}
import com.microgenesis.oo.abs.Crow
import com.microgenesis.oo.abs.Dove

def bird = null;
bird = new Dove();
println(bird.eat())
println(bird.saveBirds())
bird = new Crow();
println(bird.eat())
println(bird.saveBirds())
////////////////////////////////////////////////////////////////////////////////////////////

How to share data across the application?

 static variables and methods

-static variables are not instance specific, can be shared across multiple instances



instance variables and methods
   variables and mehtod are declared inside class , can be accessed by that object only.

static variables and methods
  variables and mehtod are declared inside class with static keyword , can be accessed by  any object in the application.


static variables:

1.declare static variable inside class with any data type.
2.variables are declared in capital letters.
3.static keyword must be used infront of type
4.public scope must be used 
5.static variables must be initalized
6.No setters and getters.

7.How to access static variables?

  Dont create Object

 Access via
  ClassName.variable

8.static variables should not be re initalized other parts of the program.
  
add one more keyword - final : constant.


package com.microgenesis.oo.staticinfo

class Message {
    static  String INFO_MESSAGE="info";
    static final String WARN_MESSAGE ="Warn";
    static final String ERROR_MESSAGE = "Error";
    static final String SUCCESS_MESSAGE ="Success";
}


Message.INFO_MESSAGE = 'Information'
//Message.WARN_MESSAGE ='Warning'
println(Message.INFO_MESSAGE)
println(Message.WARN_MESSAGE)
println(Message.ERROR_MESSAGE)
println(Message.SUCCESS_MESSAGE)

static methods: 
 are used to call methods without creating object, usefull for making utilities

package com.microgenesis.oo.staticinfo

class Logger {
    static void warn(String message) {
        println(message);
    }

    static void error(String message) {
        println(message);
    }

    static void success(String message) {
        println(message);
    }

    static void info(String message) {
        println(message);
    }
}


com.microgenesis.oo.staticinfo.Logger.warn('Warning')
println Math.random()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Advanced Groovy:

1.Functional Programming
  Closure
2.Meta Programming
   
3.DSL

////////////////////////////////////////////////////////////////////////////////////////

Functional programming:
.......................

Groovy is dynamic,object oriented , functional style programming languages.


functional programming:

functional programming invented by Alonzo Church

In 1930 two computation models were proposed.


State Machine/Turing Machine:
  Turing machine is  also formal system in mathematical logic for expressing computation based on variable abstraction.

Lambda calculus:
   Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.

      The functional programming is the reference implementation of lambda calculs.

LISP is the first Programming language implemented "functional programming" / "Lambda Calculs".

*********************************************************************************************
Functional programming is application of lambda calculs mathetical theroy.


Functional Programming principles:lambda calculs mathetical

1.side effects
2.Pure functions
3.immutablity : referential transparency.
4.function is the first class cizitens
5.no loops, but recurrsion.
6.Higher order function
//////////////////////////////////////////////////////////////////////////////////////////////

if any language supports 100% functional programming principles those lanaguages are called as 
"Pure functional Programming". some lanaguages implements parital principles those languages are called "functional style programming language".

Eg:
 java 8 is functional style language
 groovy is functional style language

/////////////////////////////////////////////////////////////////////////////////////////////

              Functional Programming concepts and implementation in Groovy
				(Closures)
.............................................................................................

What is Closure?

 The closure is object, used to implement functional programming in groovy.

 The closure is an open , anonymous(nameless),block of code that can take arg,return a value
and be assigned to a variable, can be passed as a parameter to another clousre or method.

 closure is method /function.

 "closure is free code"

 "Closure is a literal" - value like 10 ,"hello" ,true, 

Since closure is a literal, can be assigned to a variable,that variable cab be used to invoke
that closure(method/function)

eg:
   int a=10;

Basic closure syntax:
.....................

 def func = { code }

 func() // function invocation

//How to declare clourse

def func = {
    //closure body :block of code
    println "Hello Closure!!"
    println "Hello Closure!!"
    println "Hello Closure!!"
    println "Hello Closure!!"

}
func();
///////////////////////////////////////////////////////////////////////////////////////////

Args and Parameters in Closures:
................................

- Similar to methods, closures can take any type of args , including closure.
- Type of args can be dynamic,static.
- It can take default values

Syntax

 def func = { [arg1,arg2 ->]
   function body
 };
//multiple args

def add = null;
add = { int a, int b ->
    int result = a + b;
    println "The Addition Result is ${result}";
};
add(10, 10)
//with default value
add = { int a = 0, int b = 0 ->
    int result = a + b;
    println "The Addition Result is ${result}";
};
add()
//with def and value
add = { def a = 0, def b = 0 ->
    int result = a + b;
    println "The Addition Result is ${result}";
};
add()
//with out any type or def
add = { a = 0, b = 0 ->
    int result = a + b;
    println "The Addition Result is ${result}";
};
add()
//////////////////////////////////////////////////////////////////////////////////////////////

Single Args and Parameter
.........................
def sayHello = null;

sayHello = { name -> println("Hello $name") }
sayHello('Subramanian')

implicit "single parameter called  it"

"it" - it is keyword used to replace explicit single parameter.


def sayHello = null;

sayHello = { name -> println("Hello $name") }
sayHello('Subramanian')

sayHello = {println("Hello $it") }
sayHello('Subramanian')
////////////////////////////////////////////////////////////////////////////////////////////

How to return value from Closure?

//Closure Return Value
def add = null;
add = { a = 1, b = 2 ->
    def result = a + b;
    return result;
}
println "${add(3, 5)}"

add = { a = 1, b = 2 ->
    def result = a + b;
    result;
}
println "Without Return statement ${add(3, 5)}"
add = { a = 1, b = 2 ->
    def result = a + b;
}
println "Without Return statement ${add(3, 5)}"

add = { a = 1, b = 2 ->
    result = a + b;
}
println "Without Return statement ${add(3, 5)}"

add = { a = 1, b = 2 ->
    a + b;
}
println "Without Return statement ${add(3, 5)}"
//////////////////////////////////////////////////////////////////////////////////////////////////

def sayHello = null;

sayHello = { name -> name };
println sayHello('Subramanian')

//using it
sayHello = { it };
println sayHello('Subramanian')

//////////////////////////////////////////////////////////////////////////////////////////////

Closure is an Object:
......................

//Strong clsoure
Closure myclosure = { arg -> println("$arg") }
println myclosure.getClass()
def mynewClosure = { arg -> println("$arg") }
println(mynewClosure.getClass())

//calling closure
myclosure('Hai'); // myclosure.call()
myclosure.call('Hello')
mynewClosure.call('welcome')
/////////////////////////////////////////////////////////////////////////////////////////////

Function is first class citizen:
................................

-Since function(closure) is value(literal)
 can be assigned to a variable
 can be passed to another clsoure or function as parameter
 can be returned from another closure or method.


can be assigned to a variable:

def sayHello = null;
sayHello = { name -> name };

How to pass closure to a method as a parameter?


//method takes String parameter
void sayGreet(String name) {
    println("$name")
}
//hardcode value
sayGreet('Subramanian')
def firstName = 'Subramanian';
sayGreet(firstName);
//method can take closure as parameter.
void connect(def callback) {
    //invoke closure
    callback();
}
//pass closure via variable
def db = {
    println "Database Connection";
};
connect(db)
//pass closure directly
connect({
    println "NOSQL Connection"
})
///////////////////////////////////////////////////////////////////////////////////////////////////
//what if a closure takes args
void startWebServer(def callback) {
    callback('Running')
}

//def server = { status -> println "Server is $status" }
def server = { println "Server is $it" }
startWebServer(server)
//startWebServer({ status -> println "Server is $status" })
startWebServer({ println "Server is $it" })
/////////////////////////////////////////////////////////////////////////////////////////////

//method takes String parameter
void sayGreet(String name) {
    println("$name")
}
//hardcode value
sayGreet('Subramanian')
def firstName = 'Subramanian';
sayGreet(firstName);
//method can take closure as parameter.
void connect(def callback) {
    //invoke closure
    callback();
}
//pass closure via variable
def db = {
    println "Database Connection";
};
connect(db)
//pass closure directly
connect({
    println "NOSQL Connection"
})
///////////////////////////////////////////////////////////////////////////////////////////////////
//what if a closure takes args
void startWebServer(def callback) {
    callback('Running')
}

//def server = { status -> println "Server is $status" }
def server = { println "Server is $it" }
startWebServer(server)
//startWebServer({ status -> println "Server is $status" })
startWebServer({ println "Server is $it" })
///////////////////////////////////////////////////////////////////////////////////////////////////
//Passing multiple closures as parameter and invoke any of them

void login(resolve, reject) {
    //biz logic
    String userName = 'admin'
    String password = 'foo';
    if (userName.equals('admin') && password.equals('admin')) {
        resolve('Login Success')
    } else {
        reject('Login failed')
    }

}

login({
    println "$it"
}, {
    println "$it"
})

login { println "$it" } { println "$it" }
///////////////////////////////////////////////////////////////////////////////////////////

How to pass a closure as a parameter to another closure?


println "Closure as parameter to another closure"
def auth = { userName, password, resolve, reject ->

    if (userName.equals('admin') && password.equals('admin')) {
        resolve('Login Success')
    } else {
        reject('Login failed')
    }
};
auth('admin', 'admin', { println "$it" } ,{ println "$it" });

auth('admin', 'admin') { println "$it" } { println "$it" }

/////////////////////////////////////////////////////////////////////////////////////////////

Nested Closure:

 Closure inside another closure.

inner closures cant be called outside , because the scope is limited to that outter scope only.
outer closure variables can be accessed inside inner closures.

def outerClosure = {
    println("Outer closure")
    def a = 10;
    //you cant call this clousre outside
    def innerClosure = {
        println "Inner closure $a"
        def innerMost = {
            println "Inner most $a"
        }
        innerMost();
    }
    innerClosure()
}
outerClosure();

///////////////////////////////////////////////////////////////////////////////////////////

How to return a closure from another method or closure?
def counter() {
    int a = 0;
    def innerClosure = {
        ++a;
    }
    return innerClosure;
}

def res = counter();
for (int i = 0; i < 10; i++)
    println res.call()


Without Return Statement:
def counter() {
    int a = 0;
    def innerClosure = {
        ++a;
    }
}
def res = counter();
for (int i = 0; i < 10; i++)
    println res.call()

Without Return Statement and without def keyword:

def counter() {
    int a = 0;
    innerClosure = {
        ++a;
    }
}

with return statement , but without def and variable Name
def counter() {
    int a = 0;
    return {
        ++a;
    }
}

def res = counter();
for (int i = 0; i < 10; i++)
    println res.call()
///////////////////////////////////////////////////////////////////////////////////////////
Returning closure from closure:
def counter = {
    int a = 0;
    return {
        ++a;
    }
}

def res = counter();
for (int i = 0; i < 10; i++)
    println res.call()
///////////////////////////////////////////////////////////////////////////////////////////////

Closures and Built apis :

List api.

//List and closures

def list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
list.each { println "$it" }

def iterator = { println "$it" };
list.each(iterator)
def doubleIt = { println "${it * 2}" };
list.each (doubleIt)

//////////////////////////////////////////////////////////////////////////////////////////

Delegation:
..........
Dictionary meaning:
 A person designated to act for  or represent another or others; deputy.

Groovy and Delegate:
....................

Groovy language is dynamic language.

As of now , we have discussed "dynamic nature of groovy with respect to type system".

Groovy provides more dynamic programming features.

-During runtime, we can do lot of things on object.
   
A.Dynamic binding of an closure to an Object.

        "This is called delegation"

Key concepts:
.............

1.this keyword:
   this inside closure , corresponds to the enclosing class where  the closure is defined.

Where we can define closure?

-inside script
-inside groovy class

-inside script

closurethis.groovy
def mycls = {
    println this;
}
mycls()

output: The class Name
closurethis@490caf5f


-inside class:
package com.microgenesis.fp.closures

class Foo {
    def myls = {
        println this;
    }
}
def myclass = new Foo();
myclass.myls()


2.owner
   corresponds to the enclosing object where the closure is defined. 

def mycls = {
    println "this : " + this;
    println "Owner :"  + owner
}
mycls()

class Foo {
    def myls = {
        println "Foo "
        println "this : " + this;
        println "owner : " + owner;
    }
}

def myclass = new Foo();
myclass.myls()

////////////////////////////////////////////////////////////////////////////////////////
3.delegate:

 The delegate of a closure can be accessed by the delegate property.
 
Closure can be ownership can be changed object to object.

package com.microgenesis.fp.closures

class Foo {
    def myls = {
        println "Foo "
        println "this : " + this;
        println "owner : " + owner;
        println "Delegate :" + delegate

    }
}
import com.microgenesis.fp.closures.Foo

def mycls = {
    println "this : " + this;
    println "Owner :" + owner
    println "Delegate :" + delegate

}
mycls()

def myclass = new Foo();
myclass.myls()

output:
this : closurethis@24ba9639
Owner :closurethis@24ba9639
Delegate :closurethis@24ba9639
Foo 
this : com.microgenesis.fp.closures.Foo@19e4fcac
owner : com.microgenesis.fp.closures.Foo@19e4fcac
Delegate :com.microgenesis.fp.closures.Foo@19e4fcac

By defalut, all these property values are bound to object/class where we have defined.

We can change the values:


lets say i have a closure, i want to bind that closure to different objects over period.


eg:

package com.microgenesis.fp.closures

class Boss {
    String name;
}

package com.microgenesis.fp.closures

class Person {
    String name;
}



package com.microgenesis.fp.closures

class UtilClosure {
    def lowerCasedName = {
        println "this : ${this}"
        println "Owner : ${owner}"
        println "Delegate : ${delegate}"
        println("${delegate.name.toLowerCase()}")
    }
}




import com.microgenesis.fp.closures.Boss
import com.microgenesis.fp.closures.Person
import com.microgenesis.fp.closures.UtilClosure

//define closure that return uppercase
def upperCasedName = {
    println "this : ${this}"
    println "Owner : ${owner}"
    println "Delegate : ${delegate}"
    println("${delegate.name.toUpperCase()}")
}

def person = new Person(name: 'subramanian');
def boss = new Boss(name: 'Dhivya sree')
//upperCasedName()
//bind this closure to Person Object
upperCasedName.delegate = person;
println ".............After changing Delegate........"
upperCasedName()
upperCasedName.delegate = boss;
upperCasedName()
/////////////////////////////////////////////////////////////////////////////
//lower case
def util = new UtilClosure();
util.lowerCasedName.delegate = person
util.lowerCasedName()

///////////////////////////////////////////////////////////////////////////////////////////

Delegation Strategy:
....................

lookup mechnism:


eg:

def upperCasedName = {
    println "this : ${this}"
    println "Owner : ${owner}"
    println "Delegate : ${delegate}"
    println("${name.toUpperCase()}")
}
upperCasedName()


this : ClosureDelegeStrategy@69f1a286
Owner : ClosureDelegeStrategy@69f1a286
Delegate : ClosureDelegeStrategy@69f1a286
Caught: groovy.lang.MissingPropertyException: No such property: name for class: ClosureDelegeStrategy
groovy.lang.MissingPropertyException: No such property: name for class: ClosureDelegeStrategy
	at ClosureDelegeStrategy$_run_closure1.doCall(ClosureDelegeStrategy.groovy:6)
	at ClosureDelegeStrategy$_run_closure1.doCall(ClosureDelegeStrategy.groovy)
	at ClosureDelegeStrategy.run(ClosureDelegeStrategy.groovy:8)

///////////////////////////////////////////////////////////////////////////////////////////

How to change the lookup order?

Groovy first sees the method of owner, if not present, it will look up  in the delegate object.

Closure writer = {
    println "Owner $owner"
    println "this $this"
    println "delegate ${delegate}"
    println append(it);
}
//script append method: writer's owner method
def append(String str) {
    "Fake append"
}

StringBuffer sb = new StringBuffer();
//writer.resolveStrategy = Closure.DELEGATE_FIRST
//writer.resolveStrategy = Closure.OWNER_FIRST
writer.delegate = sb;
writer('Hello')
writer('Hello')
writer('Hello')


Default is "Owner First"
//////////////////////////////////////////////////////////////////////////////////////////
Closure.OWNER_FIRST ->lookup owner first, if not lookup delegate, if not ,will throw error
Closure.DELEGATE_FIRST -> lookup delegate first, if not owner , if not will thorw error.
Closure.OWNER_ONLY - lookup only in owner, if not , will throw error
Clousre.DELEGATE_ONLY - lookup only in delegate , if not will throw error.
////////////////////////////////////////////////////////////////////////////////////////////

Functional Programming concepts:
...............................
->Curry function
->Memoization - caching
->composition
->Trampoline
////////////////////////////////////////////////////////////////////////////////////////

Curry function:
...............
In Groovy, Curry function referes to the concept of partial application.

Objective:
It will let you set the value of one parameter of a clousre, it returns a new closure accepting one less argument.

def multiply = { a, b -> a * b };
def doubler = multiply.curry(10)
println doubler(10)
println doubler(40)

def log = { String type, Date createdOn, String message ->
    println "$type $createdOn $message";
}
log('Info', new Date(), 'The record is deleted')

def typeLog = log.curry("Info");
typeLog(new Date(), "The record is Inserted")
typeLog(new Date(), "The record is updated")

def dateLog = typeLog.curry(new Date());
dateLog('The record search is done!!!')


Types of Curry methods:

1.rcurry 
 pass parameters from left to right rather right to left

def divide = { a, b -> a / b }
def halver = divide.rcurry(2)
println(halver(10))
//N curry- index based curry

def volume = { double l, double w, double h ->
    l * w * h
};
def fixedwithVolume = volume.ncurry(1, 2d, 4d)
println fixedwithVolume(2d)
///////////////////////////////////////////////////////////////////////////////////////////

Composition:
...........

 Coimbining two or more clousres getting into an single closure.

"Closure composiition corresponds to the concept of function composition".

 func1 + func2 + func3 +funcN=>newFunc.

function compostion is done via an operator "<<   and >>".


def one = {
    //value of it would be output of second composed function
    it + 2
}
def two = {
    it * 3 //12
}
def three1 = one(two(4))
println three1// one(two(4))
def three = one << two // composition one(two(4))
println three(2)// one(two(4))

//This reverse operation for above one
def four = one >> two
println four(2)

///////////////////////////////////////////////////////////////////////////////////////////
Memoization:
............
Creates a caching variant of the closure

def fib
fib = {
    long n -> n < 2 ? n : fib(n - 1) + fib(n - 2)
}.memoize()
println(fib(25))

////////////////////////////////////////////////////////////////////////////////////////////

                                   Groovy Meta Programming
/////////////////////////////////////////////////////////////////////////////////////////////

What is Meta Programming?

 Meta Programming means changing the program behaviour during runtime and compile time.

Types of meta Programming:

1.Runtime meta programming
2.Compile time meta programming


1.Runtime meta Programming:
  We can postphone to runtime to intercept,inject, and even syntesize methods and properties of a class and interfaces.

Runtime meta programming can be implemented in many ways.

In java , once object created y cant add,delete any properties and methods during runtime. but in groovy this possible.

How to implement Meta programming?

Service.groovy
package com.microgenesis.groovy.metaprog.runtime

class Service {
}


RunttimeMetaProgramming.groovy

import com.microgenesis.groovy.metaprog.runtime.Service

def service = new Service();
service.name = 'subramanian'

Caught: groovy.lang.MissingPropertyException: No such property: name for class: com.microgenesis.groovy.metaprog.runtime.Service
groovy.lang.MissingPropertyException: No such property: name for class: com.microgenesis.groovy.metaprog.runtime.Service
	at RuntimeMetaProgramming.run(RuntimeMetaProgramming.groovy:4)


 groovy.lang.MissingPropertyException , this exception is thrown when a property does exit.

////////////////////////////////////////////////////////////////////////////////////////////

Every Groovy class implements groovy.lang.GroovyObject interface.


public interface GroovyObject{

public MetaClass	getMetaClass()
Returns the metaclass for a given class.
public Object	getProperty(String propertyName)
Retrieves a property value.
public Object	invokeMethod(String name, Object args)
Invokes the given method.
public void	setMetaClass(MetaClass metaClass)
Allows the MetaClass to be replaced with a derived implementation.
public void	setProperty(String propertyName, Object newValue)
Sets the given property to the new value.
}

Object types in Groovy:

1.POJO :  Plain old Java Object- It is java Object.
2.POGO  : Plain Old Groovy Object 


You will get this exception, if method not present in the Object

Caught: groovy.lang.MissingMethodException: No signature of method: com.microgenesis.groovy.metaprog.runtime.Service.sayHello() is applicable for argument types: () values: []
groovy.lang.MissingMethodException: No signature of method: com.microgenesis.groovy.metaprog.runtime.Service.sayHello() is applicable for argument types: () values: []
	at RuntimeMetaProgramming.run(RuntimeMetaProgramming.groovy:14)



////////////////////////////////////////////////////////////////////////////////////////////
package com.microgenesis.groovy.metaprog.runtime

class Service {
    //store all dynamic propertes and its values
    protected Map dynamicProperties = [:];
    //override set
    public void setProperty(String propertyName, Object newValue) {
        // println("$propertyName $newValue")
        dynamicProperties[propertyName] = newValue
    }

    def getProperty(String propertyName) {
       //  println("$propertyName")
        dynamicProperties[propertyName]
    }

    def methodMissing(String methodName,args){
        def prop = dynamicProperties[methodName]
        if(prop instanceof Closure){
            return prop(*args); // expand args[0],args[1],args[2]
        }
    }
}

import com.microgenesis.groovy.metaprog.runtime.Service

def service = new Service();
//setters
service.name = 'subramanian'
service.age = 18
service.city = "Coimbatore"
//adding methods via closure
service.sayHello = {
    println "Say Hello"
}
service.calculate = { a, b -> a + b }

println service.name + " " + service.age + service.city;
service.sayHello()
println service.calculate(10,23)
///////////////////////////////////////////////////////////////////////////////////////////

What if i dont want to add all logics like above?

Groovy offers a simple property "metaClass" through which you can add all properties and methods.

package com.microgenesis.groovy.metaprog.runtime

class UtilService {
}


def util = new UtilService();
//add new Property
util.metaClass.name = 'Subramanian'; // setter method on metaClass
println(util.name) //getter
util.metaClass.city = "Chennai"
println(util.city)
util.metaClass.add = { a, b -> a + b };
println util.add(10,10)

////////////////////////////////////////////////////////////////////////////////////////////

What if i dont want to use my own class (like UtilService) for meta Programming?

Expando:

Represents a dynamically expandable bean.

def expando = new Expando()
expando.language = 'Groovy';
expando.multiply = {it*2};
println(expando.language + " " + expando.multiply(2))
//////////////////////////////////////////////////////////////////////////////////////////////
                           Compile Time Meta Programming
..............................................................................................

Compile-time meta Programming in groovy allows code generation at compile-time.
Compiler generally generates a program (compiled program)  based on a concept "AST"
Abstract Syntax Tree - tree representation of compiled program.

Source code----compile----ast---executed.

Groovy hooks AST Transformation during compilation process.

When compare to Runtime meta programming, compile time meta programming will have changes in the byte itself -  eager process.


Implementation:
  AST transformation is done via "Annotations"


Annotation : to inject code during compile time.
///////////////////////////////////////////////////////////////////////////////////////////////
@groovy.transform

1.ToString  -
 package com.microgenesis.groovy.metaprog.compile

import groovy.transform.ToString

@ToString(excludes = ['age'],includeNames = true,includePackage = false)
class Person {
    String firstName;
    String lastName;
    String age;
    String city;
//    @Override
//    String toString() {
//        return "$firstName $lastName"
//    }
}
def person = new Person(firstName: 'Subramanian', lastName: 'Murugan', age: 18, city: 'Coimbatore');
println person.toString();

//////////////////////////////////////////////////////////////////////////////////////////

2.Equals and HashCode

 equals : method used to test two objects are same- based on id property of both objects
 hashcode: method used to get unquie identification no, every object in groovy has unquie.

package com.microgenesis.groovy.metaprog.compile

import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString

@ToString(excludes = ['age'], includeNames = true, includePackage = false)
@EqualsAndHashCode(includes = ['id', 'city'])
class Person {
    long id;
    String firstName;
    String lastName;
    String age;
    String city;
//    @Override
//    String toString() {
//        return "$firstName $lastName"
//    }
}


//equals and hash code
def p1 = new Person(id:1,firstName: 'Subramanian', lastName: 'Murugan', age: 18, city: 'Coimbatore');
def p2 = new Person(id:1,firstName: 'Ram', lastName: 'Murugan', age: 18, city: 'Chennai');

println p1.hashCode();
println p2.hashCode()
println p1.equals(p2)
////////////////////////////////////////////////////////////////////////////////////////////

3.TupleConstructor
 
 In groovy , dynamically you can generate constructors based on map like syntax.
 if you want traditional constructor calls, then you can use Tuple Constructors.


import groovy.transform.ToString
import groovy.transform.TupleConstructor

//@TupleConstructor(excludes = ['lastName'])
@TupleConstructor
@ToString(includeNames = true, includePackage = false)
class Customer {
    long id;
    String firstName;
    String lastName;
}

//map-like syntax
//def customer = new Customer(id:1,firstName: 'subramanian',lastName: 'murugan')
def customer = new Customer(1,'Subramanian','Murugan');
println customer.toString()
///////////////////////////////////////////////////////////////////////////////////////
if i want toString,EqualsAndHashcode,TupleConstructor on a class

@ToString(excludes = ['age'], includeNames = true, includePackage = false)
@EqualsAndHashCode(includes = ['id', 'city'])
@TupleConstructor
class Person { }

Groovy offers a meta annotation, all in one - @Canonical

Note: all properties are applicable 

@Canonical()
class Customer {
    long id;
    String firstName;
    String lastName;
}
//////////////////////////////////////////////////////////////////////////////////////////

Sortable:
 Implement Comparable interface for Object sorting

package com.microgenesis.groovy.metaprog.compile

import groovy.transform.Sortable

@Sortable()
class Employee {
    String first;
    String last
    Integer dob;
}
def emplist = [
        new Employee(first: 'Subu', last: 'Murugan', dob: 1980),
        new Employee(first: 'Arun', last: 'Karthik', dob: 1997),
        new Employee(first: 'Bala', last: 'Murugan', dob: 1976),
        new Employee(first: 'James', last: 'Bond', dob: 1956)
];
println emplist.sort()*.first
/////////////////////////////////////////////////////////////////////////////////////////////

Builders:
 It is one of the design pattern , used to create fluent apis.

Groovy offers lot of builder classes:

1.XML builder
2.JSON builder
3.Swing Builder
etc......
How builder looks like?

 String str = "hello".toString().trim().toUpperCase().trim()  // method chaining


How to create custom builder object?

@Builder Annotation simplies creating our own builder patterns.

Strategy:
1.SimpleStrategy


package com.microgenesis.groovy.metaprog.compile

import groovy.transform.ToString
import groovy.transform.builder.Builder
import groovy.transform.builder.SimpleStrategy

@ToString
@Builder(builderStrategy = SimpleStrategy)
class Message {
    String from, to, subject, body
}
def message = new Message()
        .setFrom("subu@gmail.com")
        .setBody("Hello")
        .setSubject("greet")
println(message.from)

ExternalStrategy:
.................
You can have bean class, you can have a separate Builder class

package com.microgenesis.groovy.metaprog.compile

import groovy.transform.builder.Builder
import groovy.transform.builder.ExternalStrategy

@Builder(builderStrategy = ExternalStrategy, forClass = Visitor)
class VisitorBuilder {
}

package com.microgenesis.groovy.metaprog.compile

class Visitor {
    String first;
    String last;
    String email;
}

def vistor = new VisitorBuilder()
        .first("Subramanian")
        .last("Murugan")
        .email("test@test.com")
        .build();
println vistor.email
////////////////////////////////////////////////////////////////////////////////////////////
Built in Builders:

JSON builder:A builder for creating JSON payloads.

...........
1.To build JSON output from the list.

import groovy.json.JsonBuilder

def list = [id    : 1, name: 'Subramanian', city: 'Coimbatore',
            skills: ['java', 'groovy', 'microservices']];

def builder = new JsonBuilder(list)
println builder.toPrettyString()

def newBuilder = new JsonBuilder();

newBuilder {
    persons {
        firstName 'Subramanian'
        lastName 'Murgan'
        address(city: 'Coimbatore', state: 'tamil Nadu')
        skills 'Java', 'Groovy'
    }
            {
                firstName 'Ram'
                lastName 'Kumar'
                address(city: 'Coimbatore', state: 'tamil Nadu')
                skills 'Java', 'Groovy'
            }
}
println newBuilder.toPrettyString()
///////////////////////////////////////////////////////////////////////////////////////////
How to convert JSON String into Object?
JsonSlurper

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

def slurper = new JsonSlurper()
String json = '{"person":{"name":"Guillaume","age":33,"pets":["dog","cat"]}}';
def result = slurper.parseText(json)
println(result)

def list = [id    : 1, name: 'Subramanian', city: 'Coimbatore',
            skills: ['java', 'groovy', 'microservices']];

def builder = new JsonBuilder(list)
String newJson = builder.toString();
def obj = slurper.parseText(newJson)
println obj


////////////////////////////////////////////////////////////////////////////////////////////

Other Annotations:

@Singleton
@Log
/////////////////////////////////////////*********************///////////////////////////////

Exception Handling
Collection Processing
File IO Processing
DSL
///////////////////////////////////////////////////////////////////////////////////////////////

                                   DSL - Domain specific language
//////////////////////////////////////////////////////////////////////////////////////////////

What is DSL?
  A domain -specific language is a computer language specialized to a particular domain.

eg dsl
   HTML,Unix shell scripts,spread sheets,XML ,regular expressions,XSLT,CSS

DSL are human readable programs, any body can read, understand,write.

Types of DSL:

1.External DSL
    It is a language that's parsed independently of the host general purpose language.
 eg ; CSS,HTML,Regular expressions
2.Internal DSL
   Internal DSL are particular form of api in a host general purpose language often
refered to as "fluent interfaces" -  fluent api/builder based api.

Groovy offers features to create internal DSLs.
 
How to implement DSL in groovy?

 We have many patterns.

1.Command Chain pattern / builder pattern

IN dsl programming there are two roles

1.DSL Authors -  the people who build dsl
2.DSL users -  the people who uses dsls

Implementation:

1.plain function
2.function + closure + map + class with builder pattern


calling dsl;

 presentation('DSL',at:'Google',on:'Dec 30')

 presentation 'DSL',at:'Google',on:'Dec 30'


Basic DSL
package com.microgenesis.groovy.dsl

def presentation(Map args, String topic) {
    println "I am Presenting about $topic at $args.at on $args.on"
}

presentation('DSL',at:'Google',on:'Dec 30')

presentation 'DSL',at:'Google',on:'Dec 30'
//////////////////////////////////////////////////////////////////////////////////////////////

Builder pattern/Command Chains:
...............................


def talk(topic) {
    def talkBuilder = new TalkBuilder(topic: topic)
    talkBuilder; // Return talk builder Object
}
//builder class
class TalkBuilder {
    def topic, location, when;
    //location function
    def at(location) {
        this.location = location
        this; // returning the TalkBuilder object
    }

    def on(when) {
        this.when = when;
        println("I am Presenting $topic at $location on $when");
        this;
    }
}

talk('DSL').at('Microsoft').on('Dec 31')
talk 'Spring With Groovy DSL ' at 'Google' on 'Jan 1'
/////////////////////////////////////////////////////////////////////////////////////////////

Function + map + Closure

///////////////////////////////////////////////////////////////////////////////////////////

//function + map + closure
def speak(topic) {
    ['at': { location ->
        ['on': {
            when -> println("I am Presenting $topic at $location on $when");
        }]
    }];
}

speak 'Spring With Groovy DSL ' at 'Google' on 'Jan 1'
////////////////////////////////////////////////////////////////////////////////////////////////////
//please show the sequare_root of 100

def show = { println it }
def square_root = { Math.sqrt(it) }

def please(action) {
    [the: {
        what ->
            [of: {
                number -> action(what(number))
            }
            ]
    }]
}
please show the square_root of 100
please show the square_root of 400
////////////////////////////////////////////////////////////////////////////////////////////

Operator overloading :
 
Operator overloading means chagining the meaning of operator.
Operator overloading helps to build more readable dsl code

def a = 10 + 10

def c = 10.plus 10
println c;
def pow = 10.power 2
println pow
//////////////////////////////////////////////////////////////////////////////////////////////

Exception Handling:

package com.microgenesis.groovy.exceptionhandling

import groovy.util.logging.Log


class Calculator {
    def divNumbers(def a = 1, def b = 1) {
        //when we write risky code: code may cause runtime error at any time
        try {
            a.div b;
        }
        catch (Exception es) {
             es.getMessage()
        }
    }
}
package com.microgenesis.groovy.exceptionhandling

def calc = new Calculator();
println calc.divNumbers(10,2)
println calc.divNumbers(10,0)

/////////////////////////////////////////////////////////////////////////////////////////////

Collection:

Groovy supports major collections
-Range Operator
-List
-Set
-Map


Range:
//range operator
//printing values i to 10
for (int i = 1; i <= 10; i++) {
    println(i)
}
//Range
1..10.each {println it}

package com.microgenesis.groovy.collections

//list
def names = ['subramanian', 'Ram', 'Karthik'];

names.each { println it }

class Product {
    Integer id;
    String name;
    double price;
}

def products = [
        new Product(id: 1, name: 'phone', price: 10.5),
        new Product(id: 2, name: 'camera', price: 90.5),
        new Product(id: 3, name: 'Laptop', price: 1990.5)

]
products.each { println "${it.id} ${it.name} ${it.price}" }

///api filter api which reutrns based true or false.

def addNumbers(item) {
    def items = [];
    items.add(item);
    items;
}

for (int i = 0; i < 10; i++) {
    addNumbers(i).each { println it }
}
//////////////////////////////////////////////////////////////////////////////////////////////
//set avoids duplicates
println "Set"
def uniqueNumbers = [1, 1, 2, 4, 5, 5, 6, 7, 8, 9, 8] as Set;
uniqueNumbers.each {println it}
/////////////////////////////////////////////////////////////////////////////////////////////////
def empDetails = [
        id:1,
        name:'Subramnian',
        salary:1000

];
println "$empDetails.id $empDetails.name $empDetails.salary"

empDetails.each {key,value->println "$key $value"}
///////////////////////////////////////////////////////////////////////////////////////////////
def letters = 'a'..'z';
letters.each {println it}

/////////////////////////////////////////////////////////////////////////////////////////////

File IO:
package com.microgenesis.groovy.fileio

def readFile() {
    try {
        def file = new File("greetings.txt")
        file.eachLine { println "$it" }
    }
    catch (Exception es) {
        println es.getMessage()
    }
}

readFile()

//list all files from the directory
def listFiles() {
    try {
        def dir = new File(/c:\ /)
        dir.eachFile { file -> println file.name }
    }
    catch (Exception es) {
        println es.getMessage()
    }
}

listFiles()

def writeData(info) {
    try {
        new File('foo.txt').withWriter('utf-8') { writer ->
            writer.writeLine(info)
        }
    }
    catch (Exception es) {
        println es.getMessage()
    }
}

writeData("Hello!! Greetings!!")

//file copy

def fileCopy() {
    try {
        def source = new File("foo.txt")
        def dest = new File("foocopy.txt")
        //copy
         dest << source.text
    }
    catch (Exception es) {
        println es.getMessage()
    }
}
fileCopy()
















































 

 































































































































